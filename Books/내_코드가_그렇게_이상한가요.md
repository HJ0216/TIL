# 내 코드가 그렇게 이상한가요?

📖 2024.03.11 -


## 3장 클래스 설계: 모든 것과 연결되는 설계 기반

### 3.2 성숙한 클래스로 성장시키는 설계 기법

```java
class Money{
    int amount;
    Currency currency;
}
```

<br/>

⭐ 생성자로 확실하게 초기값 전달받기
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>


⭐ 생성자로 전달되는 초기값 유효성 검사 추가
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }
        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>

⭐ 데이터와 관련된 계산 로직 추가
```java
class Money{
    // 생략
    
    void add(int other){
        amount += other;
    }
}
```

<br/>

⭐ 인스턴스 변수를 불변변수로 만들어 예상치 못한 동작 방어
```java
class Money{
    final int amount;
    final Currency currency;
    
    // 생략
}
```

<br/>

⭐ 불변값의 변경이 필요할 경우, 새로운 인스턴스 만들기
```java
class Money{
    // 생략

    Money add(int other){
        int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 매개변수 및 지역변수를 불변으로 선언하여 예상치 못한 동작 방어
```java
class Money{
    // 생략

    Money add(final int other){
        final int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 엉뚱한 값을 전달하지 않도록 자료형을 지정하기
```java
class Money{
    // 생략

    Money add(final Money other){
        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 메서드 로직에 유효성 검사 추가
```java
class Money{
    // 생략

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 의미없는 메서드는 추가하지 않기

<br/>

🫠 최종
```java
class Money{
    final int amount;
    final Currency currency;

    Money(final int amount, final Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }

        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```



## 4장 불변 활용하기: 안정적으로 동작하게 만들기
### 4.1 재할당
```java
int damage(){
    int tmp = member.power() + member.weaponAttack();
    tmp = (int)(tmp * (1f + member.speed() / 100f));
    tmp = tmp - (int)(enemy.defense / 2);
    tmp = Math.max(0, tmp);
}
```

<br/>

⭐ 불변 변수로 만들어서 재할당 막기
```java
int damage(){
    final int basicAttackPower = member.power() + member.weaponAttack();
    final int finalAttackPower = (int)(basicAttackPower * (1f + member.speed() / 100f));
    final int reduction = (int)(enemy.defense / 2);
    final int damage = Math.max(0, finalAttackPower - reduction);

    return damage;
}
```

<br/>

🚨 가변으로 인한 의도치 않은 영향 유의
```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new ILLegalArgumentException();
        }

        this.value = value;
    }
}

class Weapon{
    final AttackPower attackPower;

    Weapon(AttackPower attackPower){
        this.attackPower = attackPower;
    }
}


// 같은 인스턴스를 공유할 경우,

AttackPower attackPower = new AttackPower(20);
Weapon weaponA = new Weapon(attackPower);
Weapon weaponB = new Weapon(attackPower);

weaponA.attackPower.value = 25;

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 25


// 인스턴스를 개별적으로 생성한 경우,
AttackPower attackPowerA = new AttackPower(20);
AttackPower attackPowerB = new AttackPower(20);

Weapon weaponA = new Weapon(attackPowerA);
Weapon weaponB = new Weapon(attackPowerB);

weaponA.attackPower.value += 5;
System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    void reinforce(int increment){
        value += increment;
    }

    void disable(){
        value = MIN;
    }
}

AttackPower attackPower = new AttackPower(20);
attackPower.reinforce(15);
System.out.println("attackPower.value: " + attackPower.value); // 35

// 다른 스레드에서 메서드 호출
attackPower.disable();
System.out.println("attackPower.value: " + attackPower.value); // 0
```

<br/>

🚨 메서드
- 주요 작용: 매개변수를 전달받고, 값을 리턴
- 부수 효과: 주요 작용 이외의 상태 변경을 일으키는 것
    - 인스턴스 변수 변경
    - 전역변수 변경
    - 매개변수 변경
    - 파일 읽고 쓰기와 같은 I/O 조작
⭐ 함수의 영향 범위 한정하기
- 데이터(상태)는 매개변수로 전달 받기
- 상태 변경하지 않기
- 값은 함수의 리턴 값으로 돌려주기

<br/>

⭐ 값을 불변으로 바꾸기
```java
class AttackPower{
    static final int MIN = 0;
    final int value;

    AttackPower(final int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    AttackPower reinforce(final AttackPower increment){
        return new AttackPower(this.value + increment.value);
    }

    AttackPower disable(){
        return new AttackPower(MIN);
    }
}
```

<br/>

```java
class Weapon{
    final AttackPower attackPower;

    Weapon(final AttackPower attackPower){
        this.attackPower = attackPower;
    }

    Weapon reinforce(final AttackPower increment){
        final AttackPower reinforced = attackPower.reinforce(increment);
        return new Weapon(reinforced);
    }
}
```

<br/>

```java
final AttackPower attackPowerA = new AttackPower(20);
final AttackPower attackPowerB = new AttackPower(20);

final Weapon weaponA = new Weapon(attackPowerA);
final Weapon weaponB = new Weapon(attackPowerB);

final AttackPower increment = new AttackPower(5);
final Weapon reinforceWeaponA = weaponA.reinforce(increment);

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 20
System.out.println("Reinforced Weapon A attack power: " + reinforcedWeaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

⭐ 기본적으로 불변으로
- 변수의 의미가 변하지 않으므로 혼란을 줄일 수 있음
- 동작이 안정적이게 되므로 결과를 예측하기 쉬움
- 코드의 영향 범위가 한정적이므로 유지보수가 편리해짐

<br/>

cf. Mutater: 상태를 변화시키는 메서드
```java
class HitPoint{
    private static final int MIN = 0;
    int amount;

    HitPoint(final int amount){
        if(amount < MIN){
            throw new IllegalArgumentException();
        }

        this.amount = amount;
    }

    void damage(final int damageAmount){
        final int nextAmount = amount - damageAmount;
        amount = Math.max(MIN, nextAmount);
    }

    boolean isZero(){
        return amount == MIN;
    }
}

class Member{
    final HitPoint hitPoint;
    final States states;

    void damage(final int damageAmount){
        hitPoint.damage(damageAmount);
        if(hitPoint.isZero()){
            states.add(StateType.dead);
        }
    }
}
```