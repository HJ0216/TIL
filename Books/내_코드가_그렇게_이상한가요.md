# 내 코드가 그렇게 이상한가요?

📖 2024.03.11 -


## 3장 클래스 설계: 모든 것과 연결되는 설계 기반

### 3.2 성숙한 클래스로 성장시키는 설계 기법

```java
class Money{
    int amount;
    Currency currency;
}
```

<br/>

⭐ 생성자로 확실하게 초기값 전달받기
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>


⭐ 생성자로 전달되는 초기값 유효성 검사 추가
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }
        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>

⭐ 데이터와 관련된 계산 로직 추가
```java
class Money{
    // 생략
    
    void add(int other){
        amount += other;
    }
}
```

<br/>

⭐ 인스턴스 변수를 불변변수로 만들어 예상치 못한 동작 방어
```java
class Money{
    final int amount;
    final Currency currency;
    
    // 생략
}
```

<br/>

⭐ 불변값의 변경이 필요할 경우, 새로운 인스턴스 만들기
```java
class Money{
    // 생략

    Money add(int other){
        int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 매개변수 및 지역변수를 불변으로 선언하여 예상치 못한 동작 방어
```java
class Money{
    // 생략

    Money add(final int other){
        final int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 엉뚱한 값을 전달하지 않도록 자료형을 지정하기
```java
class Money{
    // 생략

    Money add(final Money other){
        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 메서드 로직에 유효성 검사 추가
```java
class Money{
    // 생략

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 의미없는 메서드는 추가하지 않기

<br/>

🫠 최종
```java
class Money{
    final int amount;
    final Currency currency;

    Money(final int amount, final Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }

        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```



## 4장 불변 활용하기: 안정적으로 동작하게 만들기
### 4.1 재할당
```java
int damage(){
    int tmp = member.power() + member.weaponAttack();
    tmp = (int)(tmp * (1f + member.speed() / 100f));
    tmp = tmp - (int)(enemy.defense / 2);
    tmp = Math.max(0, tmp);
}
```

<br/>

⭐ 불변 변수로 만들어서 재할당 막기
```java
int damage(){
    final int basicAttackPower = member.power() + member.weaponAttack();
    final int finalAttackPower = (int)(basicAttackPower * (1f + member.speed() / 100f));
    final int reduction = (int)(enemy.defense / 2);
    final int damage = Math.max(0, finalAttackPower - reduction);

    return damage;
}
```

<br/>

🚨 가변으로 인한 의도치 않은 영향 유의
```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new ILLegalArgumentException();
        }

        this.value = value;
    }
}

class Weapon{
    final AttackPower attackPower;

    Weapon(AttackPower attackPower){
        this.attackPower = attackPower;
    }
}


// 같은 인스턴스를 공유할 경우,

AttackPower attackPower = new AttackPower(20);
Weapon weaponA = new Weapon(attackPower);
Weapon weaponB = new Weapon(attackPower);

weaponA.attackPower.value = 25;

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 25


// 인스턴스를 개별적으로 생성한 경우,
AttackPower attackPowerA = new AttackPower(20);
AttackPower attackPowerB = new AttackPower(20);

Weapon weaponA = new Weapon(attackPowerA);
Weapon weaponB = new Weapon(attackPowerB);

weaponA.attackPower.value += 5;
System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    void reinforce(int increment){
        value += increment;
    }

    void disable(){
        value = MIN;
    }
}

AttackPower attackPower = new AttackPower(20);
attackPower.reinforce(15);
System.out.println("attackPower.value: " + attackPower.value); // 35

// 다른 스레드에서 메서드 호출
attackPower.disable();
System.out.println("attackPower.value: " + attackPower.value); // 0
```

<br/>

🚨 메서드
- 주요 작용: 매개변수를 전달받고, 값을 리턴
- 부수 효과: 주요 작용 이외의 상태 변경을 일으키는 것
    - 인스턴스 변수 변경
    - 전역변수 변경
    - 매개변수 변경
    - 파일 읽고 쓰기와 같은 I/O 조작

⭐ 함수의 영향 범위 한정하기
- 데이터(상태)는 매개변수로 전달 받기
- 상태 변경하지 않기
- 값은 함수의 리턴 값으로 돌려주기

<br/>

⭐ 값을 불변으로 바꾸기
```java
class AttackPower{
    static final int MIN = 0;
    final int value;

    AttackPower(final int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    AttackPower reinforce(final AttackPower increment){
        return new AttackPower(this.value + increment.value);
    }

    AttackPower disable(){
        return new AttackPower(MIN);
    }
}
```

<br/>

```java
class Weapon{
    final AttackPower attackPower;

    Weapon(final AttackPower attackPower){
        this.attackPower = attackPower;
    }

    Weapon reinforce(final AttackPower increment){
        final AttackPower reinforced = attackPower.reinforce(increment);
        return new Weapon(reinforced);
    }
}
```

<br/>

```java
final AttackPower attackPowerA = new AttackPower(20);
final AttackPower attackPowerB = new AttackPower(20);

final Weapon weaponA = new Weapon(attackPowerA);
final Weapon weaponB = new Weapon(attackPowerB);

final AttackPower increment = new AttackPower(5);
final Weapon reinforceWeaponA = weaponA.reinforce(increment);

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 20
System.out.println("Reinforced Weapon A attack power: " + reinforcedWeaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

⭐ 기본적으로 불변으로
- 변수의 의미가 변하지 않으므로 혼란을 줄일 수 있음
- 동작이 안정적이게 되므로 결과를 예측하기 쉬움
- 코드의 영향 범위가 한정적이므로 유지보수가 편리해짐

<br/>

cf. Mutater: 상태를 변화시키는 메서드
```java
class HitPoint{
    private static final int MIN = 0;
    int amount;

    HitPoint(final int amount){
        if(amount < MIN){
            throw new IllegalArgumentException();
        }

        this.amount = amount;
    }

    void damage(final int damageAmount){
        final int nextAmount = amount - damageAmount;
        amount = Math.max(MIN, nextAmount);
    }

    boolean isZero(){
        return amount == MIN;
    }
}

class Member{
    final HitPoint hitPoint;
    final States states;

    void damage(final int damageAmount){
        hitPoint.damage(damageAmount);
        if(hitPoint.isZero()){
            states.add(StateType.dead);
        }
    }
}
```



## 5장 응집도: 흩어져 있는 것들
⭐ 응집도: 클래스 내부에서 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표
### 5.1 static 메서드 오용
```java
class OrderManager{
    static int add(int moneyAmount1, int moneyAmount2){
        return moneyAMount1 + moneyAmount2;
    }
}
```
🚨 static 메서드는 인스턴스 변수를 사용할 수 없어, 데이터와 데이터를 조작하는 로직 사이에 괴리가 생겨 응집도가 낮아질 수 있음

```java
class PaymentManager{
    private int discountRate;

    int add(int moneyAmount1, int moneyAmount2){
        return moneyAmount1 + moneyAmount2;
    }
}
```
🚨 인스턴스 변수를 전혀 사용하지 않는 메서드는 static 메서드와 동일한 기능  
→ 메서드 앞에 static 추가 시, 오류가 발생하지 않는다면 인스턴스 메서드인 척 하는 static 메서드

⭐ static 메서드를 사용하면 좋은 상황
* 로그 출력 전용 메서드
* 포맷 전환 전용 메서드
등 응집도와 관계없는 기능

### 5.2 초기화 로직 분산
```java
class GiftPoint{
    private static final int MIN_POINT = 0;
    final int value;

    GiftPoint(final int point){
        if(point < MIN_POINT){
            throw new IllegalArgumentException("포인트를 0 이상 입력해야 합니다.");
        }

        value = point;
    }

    /**
     * 포인트 추가하기
     * 
     * @param other 추가 포인트
     * @return 추가 후 남은 포인트
    */
    GiftPoint add(final GiftPoint other){
        return new GiftPoint(value + other.value);
    }

    /**
     * @return 남은 포인트가 소비 포인트 이상이라면 true
    */
    boolean isEnough(final ConsumptionPoint point){
        return point.value <= value;
    }

    /**
     * 포인트 소비하기
     * 
     * @param point 소비 포인트
     * @return 소비 후 남은 포인트
    */
    GiftPoint consume(final ConsumptionPoint point){
        if(!isEnough(point)){
            throw new IllegalArgumentException("포인트가 부족합니다.");
        }

        return new GiftPoint(value - point.value);
    }
}

GiftPoint standardMembershipPoint = new GiftPoint(3000);
GiftPoint premiumMembershipPoint = new GiftPoint(10000);
```
🚨 생성자를 public으로 만들면, 의도치 않은 용도의 사용으로 관련된 로직이 분산되어 유지보수가 힘들어 질 수 있음

⭐ private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화
```java
class GiftPoint{
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;

    private GiftPoint(final int point){
        if(point < MIN_POINT){
            throw new IllegalArgumentException("포인트는 0이상 이어야 합니다.");
        }

        value = point;
    }

    /**
     * @return 표준 가입 기프트 포인트
    */
    static GiftPoint forStandardMembership(){
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }

    /**
     * @return 프리미엄 가입 기프트 포인트
    */
    static GiftPoint forPremiumMembership(){
        return new GiftPoint(PREMIUM_MEMBERSHIP_POINT);
    }
}

GiftPoint standardMembershipPoint = GiftPoint.forStandardMembership();
GiftPoint premiumMembershipPoint = GiftPoint.forPremiumMembership();
```

🚨 생성 로직이 너무 많아지면 해당 클래스의 하는 일이 불분명해지므로, 생성 전용 팩토리 클래스로 분리하는 방법을 고려

### 5.3 범용 처리 클래스(Common/Util)
```java
class Common{
    // 생략

    static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax, BigDecimal taxRate){
        return amountExcludingTax.multiply(taxRate);
    }
}
```

```java
class AmountIncludingTax{
    final BigDecimal value;

    AmountIncludingTax(final AmountExcludingTax amountExcludingTax, final TaxRate taxRate){
        value = amountExcludingTax.value.multiply(taxRate.value);
    }
}
```

⭐ 꼭 필요한 경우가 아니라면, 범용 처리 클래스를 만들지 않는 것이 좋음
→ 횡단 관심사와 같이 애플리케이션의 모든 동작에 필요한 기능은 범용 코드로 만들어도 좋음
* 로그 출력
* 오류 확인
* 디버깅
* 예외 처리
* 캐시
* 동기화
* 분산 처리 등


### 5.4 결과를 리턴하는 데 매개변수 사용하지 않기
⭐ 매개변수는 입력으로 전달하는 것이 일반적
→ 출력 매개변수 사용 시, 매개변수가 입력인지 출력인지 메서드 내부의 로직을 확인해야 함

```java
class ActorManager{
    void shift(Location location, int shiftX, int shiftY){
        location.x += shiftX;
        location.y += shiftY;
    }
}
```

```java
class Location{
    final int x;
    final int y;

    Location(final int x, final int y){
        this.x = x;
        this.y = y;
    }

    Location shift(final int shiftX, final int shiftY){
        final int nextX = x + shiftX;
        final int nextY = y + shiftY;

        return new Location(nextX, nextY);
    }
}
```

### 5.5 매개변수가 너무 많은 경우
```java
/**
 * 매직 포인트 회복하기
 * @param currentMagicPoint 현재 매직포인트 잔량
 * @param originalMaxMagicPoint 원래 매직포인트 최댓값
 * @param maxMagicPointIncrements 장비로 증가하는 매직포인트 최댓값 증가량
 * @param recoveryAMount 회복량
 * @return 회복 후의 매직포인트 잔량
*/
int recoverMagicPoint(int currentMagicPoint, int originalMaxMagicPoint, List<Integer> maxMagicPointIncrements, int recoveryAmount){
    int currentMaxMagicPoint = originalMaxMagicPoint;
    for(int each : maxMagicPointIncrements){
        currentMaxMagicPoint += each;
    }

    return Math.min(currentMagicPoint, recoveryAmount, currentMaxMagicPoint);
}
```

⭐ 개념적으로 의미 있는 단위는 모두 클래스로 만들기
→ 매개변수가 아니라 인스턴스 변수로 표현하기
```java
class MagicPoint{
    private int currentAmount;
    private int originalMaxAmount;
    private final List<Integer> maxIncrements;

    /**
     * @return 현재 매직 포인트 잔량
    */
    int current(){
        return currentAmount;
    }

    /**
     * @return 매직 포인트 최댓값
    */
    int max(){
        int amount = originalMaxAmount;
        for(int each : maxIncrements){
            amount += each;
        }

        return amount;
    }

    /**
     * 매직 포인트 회복하기
     * @param recoveryAmount 회복량
    */
    void recover(final int recoveryAmount){
        currentAmount = Math.min(currentAmount + recoveryAmount, max());
    }

    /**
     * 매직 포인트 소비하기
     * @param consumeAmount 소비량
    */
    void consume(final int consumeAmount){...}
}
```

### 5.6 메서드 체인
```java
/**
 * 갑옷 입기
 * @param memberId 장비를 변경하고 싶은 멤버의 ID
 * @param newArmor 입을 갑옷
*/
void equipArmor(int memberId, Armor newArmor){
    if(party.members[memberId].equipments.canChange){
        party.members[memberId].equipments.armor = newArmor;
    }
}
```

⭐ 상세한 로직은 호출하는 쪽이 아니라, 호출되는 쪽에 구현하기
```java
/**
 * 장비하고 있는 방어구 목록
*/
class Equipments{
    private boolean canChange;
    private Equipment head;
    private Equipment armor;
    private Equipment arm;

    /**
     * 갑옷 장비하기
     * 
     * @param newArmor 장비할 갑옷
    */
   void equipArmor(final Equipment newArmor){
    if(canChange){
        armor = newArmor;
    }
   }

    /**
     * 전체 장비 해제하기
    */
    void deactiveAll(){
        head = Equipment.EMPTY;
        armor = Equipment.EMPTY;
        arm = Equipment.EMPTY;
    }
}
```

## 6장 조건 분기: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법
### 6.1 조건 분기가 중첩되어 낮아지는 가독성
```java
if(0 < member.hitPoint){
    if(member.canAct()){
        if(magic.costMagicPoint <= member.magicPoint){
            member.consumeMagicPoint(magic.costMagicPoint);
            member.chant(magic);
        }
    }
}
```

⭐ 조기 리턴으로 중첩 제거하기
```java
if(member.hitPoint <= 0) return;

if(member.canAct()){
    if(magic.costMagicPoint <= member.magicPoint){
        member.consumeMagicPoint(magi.costMagicPoint);
        member.chant(magic);
    }
}
```

```java
if(member.hitPoint <= 0){
    return;
}
if(!member.canAct()){
    return;
}
if(member.magicPoint < magic.costMagicPoint){
    return;
}
member.consumeMagicPoint(magic.costMagicPoint);
member.chant(magic);
```

```java
float hitPointRate = member.hitPoint / member.maxHitPoint;

HealthCondition currentHealthCondition;
if(hitPointRate == 0){
    currentHealthCondition = HealthCondition.dead;
}
else if(hitPointRate < 0.3){
    currentHealthCondition = HealthCondition.danger;
}
else if(hitPointRate < 0.5){
    currentHealthCondition = HealthCondition.caution;
}
else{
    currentHealthCondition = HealthCondition.fine;
}

return currentHealthCondition;
```

⭐ 가독성을 낮추는 else 구문도 조기 리턴으로 해결하기
```java
float hitPointRate = member.hitPoint / member.maxHitPoint;

if(hitPoint == 0){
    return HealthCondition.dead;
}
else if(hitPoint < 0.3){
    return HealthCondition.danger;
}
else if(hitPoint < 0.5){
    return HealthCondition.caution;
}
else{
    return HealthCondition.fine;
}
```

```java
float hitPointRate = member.hitPoint / member.maxHitPoint;

if(hitPoint == 0){
    return HealthCondition.dead;
}
if(hitPoint < 0.3){
    return HealthCondition.danger;
}
if(hitPoint < 0.5){
    return HealthCondition.caution;
}

return HealthCondition.fine;
```

### 6.2 switch 조건문 중복
⭐ switch 조건문 중복을 해소하려면, 단일 책임 선택의 원칙을 생각해야 함  
= 조건식이 같은 조건 분기를 여러 번 작성하지 말고 한 번에 작성해야 함

```java
class Magic{
    final String name;
    final int costMagicPoint;
    final int attackPower;
    final int costTechnicalPoint;

    Magic(final MagicType magicType, final Member member){
        switch(magicType){
            case fire:
                name = "파이어";
                costMagicPoint = 2;
                attackPower = 20 + (int)(member.level * 0.5);
                costTechnicalPoint = 0;
                break;
            case lightning:
                name = "번개";
                costMagicPoint = 5 + (int)(member.level * 0.2);
                attackPower = 50 + (int)(member.level * 1.5);
                costTechnicalPoint = 5;
                break;
            case hellFire:
                name = "헬파이어";
                costMagicPoint = 16;
                attackPower = 200 + (int)(member.magicAttack * 0.5 + member.vitality * 2);
                costTechnicalPoint = 20 + (int)(member.level * 0.4);
                break;
            default:
                throw new IllegalArgumentException();
        }
    }
}
```

⭐ 인터페이스로 switch 조건문 중복 해소하기
```java
interface Shape{
    double area();
}

class Rectangle implements Shape{
    private final double width;
    private final double height;

    public double area(){
        return width * height;
    }
}

class Circle implements Shape{
    private final double radius;

    public double area(){
        return radius * radius * Math.PI;
    }
}

Shape shape = new Circle(10);
System.out.println(shape.area());
shape = new Rectangle(20, 25);
System.out.println(shape.area());
```
🤓 같은 자료형으로 사용할 수 이으므로 자료형 판정을 하지 않아도 됨  
⭐ 인터페이스를 사용하면, 조건 분기를 따로 작성하지 않고도 각각의 코드를 적절히 실행 할 수 있음

```java
interface Magic{
    String name();
    int costMagicPoint();
    int attachPower();
    int costTechnicalPoint();
}

class Fire implements Magic{
    private final Member member;

    Fire(final Member member){
        this.member = member;
    }

    public String name(){
        return "파이어";
    }

    public int costMagicPoint(){
        return 2;
    }

    public int attackPoint(){
        return 20 + (int)(member.level * 0.5);
    }

    public int costTechnicalPoint(){
        return 0;
    }
}

class Lightning implements Magic{
    private final Member member;

    Lightning(final Member member){
        this.member = member;
    }

    public String name(){
        return "번개";
    }

    public int costMagicPoint(){
        return 5 + (int)(member.level * 0.2);
    }

    public int attackPoint(){
        return 50 + (int)(member.level * 1.5);
    }

    public int costTechnicalPoint(){
        return 5;
    }
}

class HellFire implements Magic{
    private final Member member;

    HellFire(final Member member){
        this.member = member;
    }

    public String name(){
        return "헬파이어";
    }

    public int costMagicPoint(){
        return 16;
    }

    public int attackPoint(){
        return 200 + (int)(member.magicAttack * 0.5 + member.vitality * 2);
    }

    public int costTechnicalPoint(){
        return 20 + (int)(member.level * 0.4);
    }
}
```

⭐ switch 조건문이 아니라, Map으로 변경하기
```java
final Map<MagicType, Magic> magics = new HashMap<>();

final Fire fire = new Fire(member);
final Lightning lightning = new Lightning(member);
final HellFire hellFire = new HellFire(member);

magics.put(MagicType.fire, fire);
magics.put(MagicType.lightning, lightning);
magics.put(MagicType.hellFire, hellFire);

void magicAttack(final MagicType magicType){
    final Magic usingMagic = magics.get(magicType);

    showMagicName(usingMagic);
    consumeMagicPoint(usingMagic);
    consumeTechnicalPoint(usingMagic);
    magicDamage(usingMagic);
}

void showMagicName(final Magic magic){
    final String name = magic.name();
}

void consumeMagicPoint(final Magic magic){
    final int costMagicPoint = magic.costMagicPoint();
}

void consumeTechnicalPoint(final Magic magic){
    final int costTechnicalPoint = magic.costTechnicalPoint();
}

void magicDamage(final Magic magic){
    final int attachPower = magic.attackPower();
}
```

⭐ 기본 자료형을 리턴할 경우, 실수로 의미가 다른 값을 전달할 가능성이 있으므로 값 객체를 활용
```java
interface Magic{
    String name();
    MagicPoint costMagicPoint();
    AttackPower attackPower();
    TechnicalPoint costTechnicalPoint();
}

class Fire implements Magic{
    private final Member member;

    Fire(final Member member){
        this.member = member;
    }

    public String name(){
        return "파이어";
    }

    public MagicPoint costMagicPoint(){
        return new MagicPoint(2);
    }

    public AttackPower attackPoint(){
        final int value = 20 + (int)(member.level * 0.5);
        return AttackPower(value);
    }

    public TechnicalPoint costTechnicalPoint(){
        return new TechnicalPoint(0);
    }
}

class Lightning implements Magic{
    private final Member member;

    Lightning(final Member member){
        this.member = member;
    }

    public String name(){
        return "번개";
    }

    public MagicPoint costMagicPoint(){
        final int value = 5 + (int)(member.level * 0.2);
        return new MagicPoint(value);
    }

    public AttackPoint attackPoint(){
        final int value = 50 + (int)(member.level * 1.5);
        return new AttackPoint(value);
    }

    public TechnicalPoint costTechnicalPoint(){
        return new TechnicalPoint(5);
    }
}

class HellFire implements Magic{
    private final Member member;

    HellFire(final Member member){
        this.member = member;
    }

    public String name(){
        return "헬파이어";
    }

    public MagicPoint costMagicPoint(){
        return new MagicPoint(16);
    }

    public AttackPoint attackPoint(){
        final int value = 200 + (int)(member.magicAttack * 0.5 + member.vitality * 2);
        return new AttackPoint(value);
    }

    public TechnicalPoint costTechnicalPoint(){
        final int value = 20 + (int)(member.level * 0.4);
        return new TechnicalPoint(value);
    }
}
```

### 6.3 조건 분기 중복과 중첩
```java
/**
 * @return 골드 회원이라면 true;
 * @param history 구매 이력
*/
boolean isGoldCustomer(PurchaseHistory history){
    if(1000000 <= history.totalAmount){
        if(10 <= history.purchaseFrequencyPerMonth){
            if(history.returnRate <= 0.001){
                return true;
            }
        }
    }
    return false;
}

/**
 * @return 실버 회원이라면 true
 * @param history 구매 이력
*/
boolean isSliverCustomer(PurchaseHistory history){
    if(10 <= history.purchaseFrequencyPerMonth){
        if(history.returnRate <= 0.001){
            return true;
        }
    }
    return false;
}
```

⭐ 정책 패턴: 조건을 부품처럼 만들고, 부품으로 만든 조건을 조합해서 사용하는 패턴
```java
interface ExcellentCustomerRule{
    /**
     * @param history 구매 이력
     * @return 조건을 만족하는 경우, true
    */
    boolean ok(final PurchaseHistory history);
}

class GoldCustomerPurchaseAmountRule implements ExcellentCustomerRule{
    public boolean ok(final PurchaseHistory history){
        return 1000000 <= history.totalAmount;
    }
}

class PurchaseFrequencyRule implements ExcellentCustomerRule{
    public boolean ok(final PurchaseHistory history){
        return 10 <= history.purchaseFrequencyPerMonth;
    }
}

class ReturnRateRule implements ExcellentCustomerRule{
    public boolean ok(final PurchaseHistory history){
        return history.returnRate <= 0.001;
    }
}

class ExcellentCustomerPolicy{
    private final Set<ExcellentCustomerRule> rules;

    ExcellentCustomerPolicy(){
        rules = new HashSet();
    }

    /**
     * 규칙 추가
     * 
     * @param rule 규칙 추가
    */
    void add(final ExcellentCustomerRule rule){
        rules.add(rule);
    }

    /**
     * @param history 구매 이력
     * @return 규칙을 모두 만족하는 경우 true
    */
    void complyWithAll(final PurchaseHistory history){
        for(ExcellentCustomerRule each : rules){
            if(!each.ok(history)){
                return false;
            }
            return true;
        }
    }
}
```

```java
ExcellentCustomerPolicy goldCustomerPolicy = new ExcellentCustomerPolicy();

goldCustomerPolicy.add(new GoldCustomerPurchaseAmountRule());
goldCustomerPolicy.add(new PurchaseFrequencyRule());
goldCustomerPolicy.add(new ReturnRateRule());

goldCustomerPolicy.complyWithAll(purchaseHistory);
```

⭐ 클래스를 활용해 골드 회원과 무관한 로직이 삽입될 가능성을 낮춤
```java
class GoldCustomerPolicy{
    private final ExcellentCustomerPolicy policy;

    GoldCustomerPolicy(){
        policy = new ExcellentCustomerPolicy();

        policy.add(new GoldCustomerPurchaseAmountRule());
        policy.add(new PurchaseFrequencyRule());
        policy.add(new ReturnRateRule());
    }

    /**
     * @param history 구매 이력
     * @return 규칙을 모두 만족할 경우, true
    */
    boolean complyWithAll(final PurchaseHistory history){
        return policy.complyWithAll(history);
    }
}
class SliverCustomerPolicy{
    private final ExcellentCustomerPolicy policy;

    SliverCustomerPolicy(){
        policy = new ExcellentCustomerPolicy();

        policy.add(new GoldCustomerPurchaseAmountRule());
        policy.add(new PurchaseFrequencyRule());
        policy.add(new ReturnRateRule());
    }

    /**
     * @param history 구매 이력
     * @return 규칙을 모두 만족할 경우, true
    */
    boolean complyWithAll(final PurchaseHistory history){
        return policy.complyWithAll(history);
    }
}
```

### 6.4 자료형 확인에 조건 분기 사용하지 않기
```java
interface HotelRates{
    Money fee();
}

class RegularRate implements HotelRates{
    public Money fee(){
        return new Money(70000);
    }
}
class PremiumRate implements HotelRates{
    public Money fee(){
        return new Money(120000);
    }
}

Money busySeasonFee;
if(hotelRates instanceof RegularRates){
    busySeasonFee = hotelRates.fee().add(new Money(30000));
}
if(hotelRates instanceof PremiumRates){
    busySeasonFee = hotelRates.fee().add(new Money(30000));
}
```
🚨 기반 자료형을 하위 자료형으로 변경해도, 코드는 문제없이 동작해야 한다는 리스코프 치환 원칙 위반  
→ 리스코프 치환 원칙을 위반하면 자료형 판정을 위한 조건 분기 코드가 점점 많아져 유지 보수가 어려워짐


```java
interface HotelRates{
    Money fee();
    Money busySeasonFee();
}

class RegularRate implements HotelRates{
    public Money fee(){
        return new Money(70000);
    }

    public Money busySeasonFee(){
        return fee().add(new Money(30000))
    }
}
class PremiumRate implements HotelRates{
    public Money fee(){
        return new Money(120000);
    }

    public Money busySeasonFee(){
        return fee().add(new Money(50000))
    }
}
```

### 6.5 인터페이스 사용 능력이 중급으로 올라가는 첫걸음
||초보자|중급자 이상|
|------|---|---|
|분기|if 조건문과 switch 조건문만 사용|인터페이스 설계 사용|
|분기마다의 처리|로직을 그냥 작성|클래스 사용|

### 6.6 플래그 매개변수
```java
damage(true, damageAmount);

void damage(boolean damageFlag, int damageAmount){
    if(damageFlag == true){
        member.hitPoint -= damageAmount;
        if(0 < member.hitPoint){return;}

        member.hitPoint = 0;
        member.addState(StateType.dead);
    }
    else{
        member.magicPoint -= damageAmount;
        if(0 <member.magicPoint){return;}

        member.magicPoint = 0;
    }
}
```

⭐ 메서드는 하나의 기능만 하도록 설계하는 것이 좋음  
= 기능별로 나누고, 각각의 메서드에 맞는 이름을 붙이면 가독성이 높아짐
```java
void hitPointDamage(final int damageAmount){
    member.hitPoint -= damageAmount;
    if(0 < member.hitPoint){return;}

    member.hitPoint = 0;
    member.addState(StateType.dead);
}
void magicPointDamage(final int damageAmount){
    member.magicPoint -= damageAmount;
    if(0 <member.magicPoint){return;}

    member.magicPoint = 0;    
}
```

🥸 플래그 매개변수를 대체하는 전략 패턴
```java
interface Damage{
    void execute(final int damageAmount);
}

class HitPointDamage implements Damage{
    // 생략

    public void execute(final int damageAmount){
        member.hitPoint -= damageAmount;
        if(0 < member.hitPoint){return;}

        member.hitPoint = 0;
        member.addState(StateType.dead);
    }
}

class MagicPointDamage implements Damage{
    // 생략

    public void execute(final int damageAmount){
        member.magicPoint -= damageAmount;
        if(0 <member.magicPoint){return;}

        member.magicPoint = 0;  
    }
}

enum DamageType{
    hitPoint
    , magicPoint
}

private final Map<DamageType, Damage> damages;

void applyDamage(final DamageType damageType, final int damageAmount){
    final Damage damage = damages.get(damageType);
    damage.execute(damageAmount);
}

applyDamage(DamageType.magicPoint, damageAmount);
```



## 7장 컬렉션: 중첩을 제거하는 구조화 테크닉
### 7.1 이미 존재하는 기능을 다시 구현하지 말기
```java
boolean hasPrisonKey = false;
for(Item each : items){
    if(each.name.equals("감옥 열쇠")){
        hasPrisonKey = true;
        break;
    }
}
```
```java
boolean hasPrisonKey = items.stream().anyMatch(
    item -> item.name.equals("감옥 열쇠");
)
```

### 7.2 반복 처리 내부의 조건 분기 중첩
⭐ 조기 컨티뉴로 조건 분기 중첩 제거하기
```java
for(Member member : members){
    if(0 < member.hitPoint){
        if(member.containsState(StateType.poison)){
            member.hitPoint -= 10;

            if(member.hitPoint <= 0){
                member.hitPoint = 0;
                member.addState(StateType.dead);
                member.removeState(StateType.poison);
            }
        }
    }
}
```

```java
for(Member member : members){
    if(member.hitPoint == 0){
        continue;
    }

    if(member.containsState(StateType.poison)){
        member.hitPoint -= 10;

        if(member.hitPoint <= 0){
            member.hitPoint = 0;
            member.addState(StateType.dead);
            member.removeState(StateType.poison);
        }
    }
}
```

```java
for(Member member : members){
    if(member.hitPoint == 0){
        continue;
    }
    if(!member.containsState(StateType.poison)){
        continue;
    }

    if(0 < member.hitPoint){
        continue;
    }

    member.hitPoint = 0;
    member.addState(StateType.dead);
    member.removeState(StateType.poison);
}
```

⭐ 조기 브레이크로 중첩 제거하기
```java
int totalDamage = 0;

for(Member member : members){
    if(member.hasTeamAttackSucceeded()){
        int damage = (int)(member.attack() * 1.1);

        if(30 <= damage){
            totalDamage += damage;
        }
        else{
            break;
        }
    }
    else{
        break;
    }
}
```

```java
int totalDamage = 0;

for(Member member : members){
    if(!member.hasTeamAttackSucceeded()){
        break;
    }

    int damage = (int)(member.attack() * 1.1);

    if(damage < 30){
        break;
    }

    totalDamage += damage;
}
```

### 7.3 응집도가 낮은 컬렉션 처리
```java
class FieldManager{
    void addMember(List<Member> members, Member newMember){
        if(members.stream().anyMatch(member -> member.id == newMemberId)){
            throw new RuntimeException("이미 존재하는 멤버입니다.");
        }
        
        if(members.size() == MAX_MEMBER_COUNT){
            throw new RuntimeException("이 이상 멤버를 추가할 수 없습니다.");
        }

        members.add(newMember);
    }

    boolean partyIsAlive(List<Member> members){
        return members.stream().anyMatch(member -> member.isAlive());
    }
}
```

⭐ 컬렉션과 관련된 응집도가 낮아지는 문제는 일급 컬렉션 패턴을 사용해 해결 할 수 있음
* 컬렉션 자료형의 인스턴스 변수
* 컬렉션 자료형의 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드


```java
class Party{
    static final int MAX_MEMBER_COUNT = 4;
    private final List<Member> members;

    Party(){
        members = new ArrayList<Member>();
    }

    /**
     * 멤버 추가하기
     * @param newMember 추가하고 싶은 멤버
     * @return 멤버를 추가한 파티
    */
    Party add(final Member newMember){
        if(exists(newMember)){
            throw new RuntimeException("이미 존재하는 멤버입니다.");
        }
        if(isFull()){
            throw new RuntimeException("이 이상 멤버를 추가할 수 없습니다.");
        }

        final List<Member> adding = new ArrayList<>(members);
        adding.add(newMember);
        return new Party(adding);
    }

    /**
     * @return 파티 멤버가 1명이라도 살아 있으면 true를 리턴
    */
    boolean isAlive(){
        return members.stream().anyMatch(each -> each.isAlive());
    }

    /**
     * @param member 파티에 소속되어있는지 확인하고 싶은 맴버
     * @return 이미 소속되어 있는 경우 true를 리턴
    */
    boolean exists(final Member member){
        return members.stream().anyMatch(each -> each.Id == member.Id);
    }

    /**
     * @return 파티 인원이 최대일 경우 true를 리턴
    */
    boolean isFull(){
        return members.size() == MAX_MEMBER_COUNT;
    }

    List<Member> members(){
        return members;
    }
}
```
🚨 인스턴스 변수를 그대로 외부에 전달하면, Party 클래스를 외부에서 마음대로 멤버를 추가하고 제거할 수 있으므로 컬렉션 요소를 변경하지 못하게 막아두어야 함

```java
class Party{
    // 생략

    /**
     * @return 멤버 리스트(단, 요소를 외부에서 변경할 수 없음ㄴ)
    */
    List<Member> member(){
        return members.unmodifiableList();
    }
}
```



## 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조
### 8.1 결합도와 책무
```java
class DiscountManager{
    List<Product> discountProducts;
    int totalPrice;

    /**
     * 상품 추가하기
     * 
     * @param product 상품
     * @param productDiscount 상품 할인 정보
     * @return 추가에 성공하면 true
    */
    boolean add(Product product, ProductDiscount productDiscount){
        if(product.id < 0){
            throw new IllegalArgumentException();
        }
        if(product.name.isEmpty()){
            throw new IllegalArgumentException();
        }
        if(product.price < 0){
            throw new IllegalArgumentException();
        }
        if(product.id != productDiscount.id){
            throw new IllegalArgumentException();
        }

        int discountPrice = getDiscountPrice(product.price);

        int tmp;
        if(productDiscount.canDiscount){
            tmp = totalPrice + discountPrice;
        }
        else{
            tmp = totalPrice + product.price;
        }
        if(tmp <= 200000){
            totalPrice = tmp;
            discountProducts.add(product);
            
            return true;
        }
        else{
            return false;
        }
    }

    static int getDiscountPrice(int price){
        int discountPrice = price - 3000;
        if(discountPrice < 0){
            discountPrice = 0;
        }

        return discountPrice;
    }
}

class Product{
    int id;
    String name;
    int price;
}

class ProductDiscount{
    int id;
    boolean canDiscount;
}
```

➕ 일반 할인 외 여름 할인 사양 추가
```java
class SummerDiscountManager{
    DiscountManager discountManager;

    /**
     * 상품 추가하기
     * 
     * @param product 상품
     * @return 추가에 성공하면 true
    */
    boolean add(Product product){
        if(product.id < 0){
            throw new IllegalArgumentException();
        }
        if(product.name.isEmpty()){
            throw new IllegalArgumentException();
        }

        int tmp;
        if(product.canDiscount){
            tmp = discountManager.totalPrice + DiscountManager.getDiscountPrice(product.price);
        }
        else{
            tmp = discountManager.totalPrice + product.price;
        }
        if(tmp <= 300000){
            discountManager.totalPrice = tmp;
            discountManager.discountProducts.add(product);
            
            return true;
        }
        else{
            return false;
        }    
}

class Product{
    int id;
    String name;
    int price;
    boolean canDiscount;
}
```
🚨 문제점
* DiscountManager, SummerDiscountManager가 상품 정보 확인 외에도 할인 가격 계산 할인 적용 여부 등 너무 많은 일을 하고 있음
* Product가 직접해야하는 유효성 검사 로직이 DiscountManager, SummerDiscountManager에 구현
* ProductDiscount.canDiscount, Product.canDiscount 이름이 유사해 어떤 것이 일반 할인이고 여름 할인인지 알 수 없음
* SummerDiscountManager가 DiscountManager의 일반 랄인 로직을 활용

⭐ 단일 책임 원칙을 지키도록 설계 변경
```java
class RegularPrice{
    private static final int MIN_AMOUNT = 0;
    final int amount;

    RegularPrice(final int amount){
        if(amount < MIN_AMOUNT){
            throw new IllegalArgumentException("가격은 0 이상이어야 합니다.");
        }

        this.amount = amount;
    }
}

class RegularDiscountedPrice{
    private static final int MIN_AMOUNT = 0;
    private static final int DISCOUNT_AMOUNT = 4000;
    final int amount;

    RegularDiscountedPrice(final RegularPrice price){
        int discountedAmount = price.amount - DISCOUNT_AMOUNT;
        if(discountedAmount < MIN_AMOUNT){
            discountedAmount = MIN_AMOUNT;
        }
    }

    amount = discountedAmount;
}

class SummerDiscountedPrice{
    private static final int MIN_AMOUNT = 0;
    private static final int DISCOUNT_AMOUNT = 3000;
    final int amount;

    SummerDiscountedPrice(final RegularPrice price){
        int discountedAmount = price.amount - DISCOUNT_AMOUNT;
        if(discountedAmount < MIN_AMOUNT){
            discountedAmount = MIN_AMOUNT;
        }
    }

    amount = discountedAmount;
}
```
⭐ 일반 할인과 여름 할인은 서로 다른 개념  
DRY는 각각의 개념 단위 내에서 반복을 하지 말라는 의미  
같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 함  
개념적으로 다른 것까지도 무리하게 중복을 제거하려 하면, 강한 결합 상태가 됨

### 8.2 다양한 강한 결합 사례와 대처 방법
🚨 상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발
```java
class PhysicalAttack{
    int singleAttackDamage(){...}
    int doubleAttackDamage(){...}
}

class FighterPhysicalAttack extends PhysicalAttack{
    @Override
    int singleAttackDamage(){
        return super.singleAttackDamage() + 20;
    }

    @Override
    int doubleAttackDamage(){
        return super.doubleAttackDamage() + 10;
    }
}
```

⭐ 슈퍼 클래스 의존으로 인한 강한 결합을 피하려면 상속보다 컴포지션을 사용하는 것이 좋음  
* 컴포지션이란 사용하고 싶은 클래스를 private 인스턴스 변수로 갖고 사용하는 것을 의미
```java
class FighterPhysicalAttack{
    private final PhysicalAttack physicalAttack;

    int singleAttackDamage(){
        return physicalAttack.singleAttackDamage() + 20;
    }

    int doubleAttackDamage(){
        return physicalAttack.doubleAttackDamage() + 10;
    }    
}
```

🚨 슈퍼 클래스를 사용해서 무리하게 일반화하는 경우
```java
abstract class DiscountBase{
    protected int price;

    int getDiscountedPrice(){
        int discountedPrice = price - 3000;
        if(discountedPrice < 0){
            discountedPrice = 0;
        }

        return discountedPrice;
    }
}

class RegularDiscount extends DiscountBase{
    @Override
    int getDiscountedPrice(){
        int discountedPrice = price - 4000;
        if(discountedPrice < 0){
            discountedPrice = 0;
        }

        return discountedPrice;
    }
}
```

```java
abstract class DiscountBase{
    // 생략

    int getDiscountedPrice(){
        int discountedPrice = price - discountCharge();
        if(discountedPrice < 0){
            discountedPrice = 0;
        }

        return discountedPrice;
    }

    protected int discountCharge(){
        return 3000;
    }
}

class RegularDiscount extends DiscountBase{
    @Override
    int discountCharge(){
        return 4000;
    }
}
```
* discountCharge 메서드를 오버라이드하려면 슈퍼 클래스의 getDiscountedPrice가 어떤 형태의 로직인지 알아야 함  
→ 하나의 로직으로 봐야 하는 흐름이 두 클래스에 분산되어 있음

```java
class SummerDiscount extends DiscountBase{
    @Override
    int getDiscountedPrice(){
        return (int)(price * (1.00 - 0.05));
    }
}
```
* 서브 클래스 중 일부와만 관련된 메서드가 등장하면 어디서부터 어디까지 관련있는지 로직을 추적하기 어려움

```java
abstract class DiscountBase{
    // 생략

    int getDiscountedPrice(){
        if(this instanceof RegularDiscount){
            int discountedPrice = price - 4000
            if(discountedPrice < 0){
                discountedPrice = 0;
            }

            return discountedPrice;
        }
        else if(this instanceof SummerDiscount) {
            return (int)(price * (1.00 - 0.05));
        }
    }
}
```
🚨 상속은 다른 동작을 구현하기 위해 사용하는 것으로 전략 패턴 등으로 조건 분기를 줄일 수 있으나, 분기를 줄이지 못하는 문제가 있음  
🚨 일반 할인과 여름 할인 로직은 RegularDiscount와 SummerDiscount에 캡슐화되어있어야 함  

⭐ 상속은 반드시 단일 책임 원칙을 염두에 두고 구현  
⭐ 값 객체와 컴포지션 등 다른 설계를 사용할 수 없는지 반드시 검토

🫠 인스턴스 변수별로 클래스 분할
```java
class Util{
    private int reservationId;
    private ViewSettings viewSettings;
    private MailMagazine mailMagazine;

    void cancelReservation(){
        // reservationId를 사용한 예약 취소 처리
    }

    void darkMode(){
        // viewSettings를 사용한 다크 모드 표시 전환 처리
    }

    void beginSendMail(){
        // mailMagazine을 사용한 메일 전송 처리
    }
}
```

```java
class Reservation{
    private final int reservationId;

    void cancel(){...}
}
class ViewCustomizing{
    private final ViewSettings viewSettings;

    void darkMode(){...}
}
class MailMagazineService{
    private final MailMagazine mailMagazine;

    void beginSendMail(){...}
}
```

🚨 특별한 이유없이 public 사용하지 않기
```java
package rpg.objects;

public class HitPointRecovery{
    /**
     * @param chanter 회복 마법 시전자
     * @param targetMemberId 회복 마법을 받는 멤버의 ID
     * @param positiveFeelings 멤버 간의 호감도
    */
    public HitPointRecovery(final Member chanter, final int targetMemberId, final PositiveFeelings positiveFeelings){
        final int basicRecoverAmount = (int)(chanter.magicPower * MAGIC_POWER_COEFFICIENT) + (int)(chanter.affection * AFFECTION_COEFFICIENT * positiveFeelings.value(chanter.id, targetMemberId));
    }
}
```
```java
package rpg.objects;

/**
 * 멤버들의 호감도
 * subject가 target에게 가지는 호감도를 확인하거나, 증가/감소시킵니다.
 * subjectId와 targetId는 subject, target과 관련 있는 멤버의 Id를 나타냅니다.
*/
public class PositiveFeelings{
    /**
     * @return 호감도
     * @param subjectId 호감도를 확인하고 싶은 멤버의 ID
     * @param targetId 호감 대상 멤버의 ID
    */
   public int value(int subjectId, int targetId){...}

    /**
     * 호감도 증가시키기
     * @param subjectId 호감도를 증가시키고자 하는 멤버의 ID
     * @param targetId 호감 대상 멤버의 ID
    */
   public int increase(int subjectId, int targetId){...}

    /**
     * 호감도 감소시키기
     * @param subjectId 호감도를 감소시키고자 하는 멤버의 ID
     * @param targetId 호감 대상 멤버의 ID
    */
   public int decrease(int subjectId, int targetId){...}
}
```

🚨 내부에서만 다루고 싶은 클래스를 다른 패키지에서 호출하는 문제
```java
package rpg.view;
import rpg.objects;

/**
 * 전투 화면
*/
public class BattleView{
    // 생략

    /** 공격 애니메이션 시작 */
    public void startAttackAnimation(){
        // 생략
        positiveFeelings.increase(member1.id, member2.id);
    }
}
```

⭐ 패키지간의 불필요한 의존 관계를 피할 때, package private가 적절  
패키지는 밀접한 클래스를 응집하게 설계하고 바깥 패키지의 클래스와는 느슨하게 결합하도록 설계

🚨 관련이 깊다고 생각되는 로직을 한 곳에 모으려고 강한 결합 구조를 만드는 것을 유의
```java
class SellingPrice{
    final int amount;

    SellingPrice(final int amount){
        if(amount < 0){
            throw new IllegalArgumentException("가격은 0이상이어야 합니다.");
        }
        this.amount = amount;
    }

    int calcSellingCommission(){
        return (int)(amount * SELLING_COMMISSION_RATE);
    }

    int calcDeliveryCharge(){
        return DELIVERY_FREE_MIN <= amount ? 0 : 5000;
    }

    int calcShoppingPoint(){
        return (int)(amount * SHOPPING_POINT_RATE);
    }
}
```

```java
class SellingCommission{
    private static final float SELLING_COMMISSION_RATE = 0.05f;
    final int amount;

    SellingCommission(final SellingPrice sellingPrice){
        amount = (int)(sellingPrice.amount * SELLING_COMMISSION_RATE);
    }
}

class DeliveryCharge{
    private static final int DELIVERY_FREE_MIN = 20000;
    final int amount;

    DeliveryCharge(final SellingPrice sellingPrice){
        amount = DELIVERY_FREE_MIN <= sellingPrice.amount ? 0 : 5000;
    }
}

class ShoppingPoint{
    private static final float SHOPPING_POINT_RATE = 0.01f;
    final int value;

    ShoppingPoint(final SellingPrice sellingPrice){
        value = (int)(sellingPrice.amount * SHOPPING_POINT_RATE);
    }
}
```









































