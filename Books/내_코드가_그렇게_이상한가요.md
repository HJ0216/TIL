# 내 코드가 그렇게 이상한가요?

📖 2024.03.11 -


## 3장 클래스 설계: 모든 것과 연결되는 설계 기반

### 3.2 성숙한 클래스로 성장시키는 설계 기법

```java
class Money{
    int amount;
    Currency currency;
}
```

<br/>

⭐ 생성자로 확실하게 초기값 전달받기
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>


⭐ 생성자로 전달되는 초기값 유효성 검사 추가
```java
class Money{
    int amount;
    Currency currency;

    Money(int amount, Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }
        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }
}
```

<br/>

⭐ 데이터와 관련된 계산 로직 추가
```java
class Money{
    // 생략
    
    void add(int other){
        amount += other;
    }
}
```

<br/>

⭐ 인스턴스 변수를 불변변수로 만들어 예상치 못한 동작 방어
```java
class Money{
    final int amount;
    final Currency currency;
    
    // 생략
}
```

<br/>

⭐ 불변값의 변경이 필요할 경우, 새로운 인스턴스 만들기
```java
class Money{
    // 생략

    Money add(int other){
        int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 매개변수 및 지역변수를 불변으로 선언하여 예상치 못한 동작 방어
```java
class Money{
    // 생략

    Money add(final int other){
        final int added = amount + other;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 엉뚱한 값을 전달하지 않도록 자료형을 지정하기
```java
class Money{
    // 생략

    Money add(final Money other){
        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 메서드 로직에 유효성 검사 추가
```java
class Money{
    // 생략

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```

<br/>

⭐ 의미없는 메서드는 추가하지 않기

<br/>

🫠 최종
```java
class Money{
    final int amount;
    final Currency currency;

    Money(final int amount, final Currency currency){
        if(amount < 0){
            throw new IllegalArgumentException("금액은 0 이상의 값을 입력해주세요.");
        }

        if(currency == null){
            throw new NullPointerException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }

    Money add(final Money other){
        if(!currency.equals(other.currency)){
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }

        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```



## 4장 불변 활용하기: 안정적으로 동작하게 만들기
### 4.1 재할당
```java
int damage(){
    int tmp = member.power() + member.weaponAttack();
    tmp = (int)(tmp * (1f + member.speed() / 100f));
    tmp = tmp - (int)(enemy.defense / 2);
    tmp = Math.max(0, tmp);
}
```

<br/>

⭐ 불변 변수로 만들어서 재할당 막기
```java
int damage(){
    final int basicAttackPower = member.power() + member.weaponAttack();
    final int finalAttackPower = (int)(basicAttackPower * (1f + member.speed() / 100f));
    final int reduction = (int)(enemy.defense / 2);
    final int damage = Math.max(0, finalAttackPower - reduction);

    return damage;
}
```

<br/>

🚨 가변으로 인한 의도치 않은 영향 유의
```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new ILLegalArgumentException();
        }

        this.value = value;
    }
}

class Weapon{
    final AttackPower attackPower;

    Weapon(AttackPower attackPower){
        this.attackPower = attackPower;
    }
}


// 같은 인스턴스를 공유할 경우,

AttackPower attackPower = new AttackPower(20);
Weapon weaponA = new Weapon(attackPower);
Weapon weaponB = new Weapon(attackPower);

weaponA.attackPower.value = 25;

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 25


// 인스턴스를 개별적으로 생성한 경우,
AttackPower attackPowerA = new AttackPower(20);
AttackPower attackPowerB = new AttackPower(20);

Weapon weaponA = new Weapon(attackPowerA);
Weapon weaponB = new Weapon(attackPowerB);

weaponA.attackPower.value += 5;
System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

```java
class AttackPower{
    static final int MIN = 0;
    int value;

    AttackPower(int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    void reinforce(int increment){
        value += increment;
    }

    void disable(){
        value = MIN;
    }
}

AttackPower attackPower = new AttackPower(20);
attackPower.reinforce(15);
System.out.println("attackPower.value: " + attackPower.value); // 35

// 다른 스레드에서 메서드 호출
attackPower.disable();
System.out.println("attackPower.value: " + attackPower.value); // 0
```

<br/>

🚨 메서드
- 주요 작용: 매개변수를 전달받고, 값을 리턴
- 부수 효과: 주요 작용 이외의 상태 변경을 일으키는 것
    - 인스턴스 변수 변경
    - 전역변수 변경
    - 매개변수 변경
    - 파일 읽고 쓰기와 같은 I/O 조작

⭐ 함수의 영향 범위 한정하기
- 데이터(상태)는 매개변수로 전달 받기
- 상태 변경하지 않기
- 값은 함수의 리턴 값으로 돌려주기

<br/>

⭐ 값을 불변으로 바꾸기
```java
class AttackPower{
    static final int MIN = 0;
    final int value;

    AttackPower(final int value){
        if(value < MIN){
            throw new IllegalArgumentException();
        }

        this.value = value;
    }

    AttackPower reinforce(final AttackPower increment){
        return new AttackPower(this.value + increment.value);
    }

    AttackPower disable(){
        return new AttackPower(MIN);
    }
}
```

<br/>

```java
class Weapon{
    final AttackPower attackPower;

    Weapon(final AttackPower attackPower){
        this.attackPower = attackPower;
    }

    Weapon reinforce(final AttackPower increment){
        final AttackPower reinforced = attackPower.reinforce(increment);
        return new Weapon(reinforced);
    }
}
```

<br/>

```java
final AttackPower attackPowerA = new AttackPower(20);
final AttackPower attackPowerB = new AttackPower(20);

final Weapon weaponA = new Weapon(attackPowerA);
final Weapon weaponB = new Weapon(attackPowerB);

final AttackPower increment = new AttackPower(5);
final Weapon reinforceWeaponA = weaponA.reinforce(increment);

System.out.println("Weapon A attack power: " + weaponA.attackPower.value); // 20
System.out.println("Reinforced Weapon A attack power: " + reinforcedWeaponA.attackPower.value); // 25
System.out.println("Weapon B attack power: " + weaponB.attackPower.value); // 20
```

<br/>

⭐ 기본적으로 불변으로
- 변수의 의미가 변하지 않으므로 혼란을 줄일 수 있음
- 동작이 안정적이게 되므로 결과를 예측하기 쉬움
- 코드의 영향 범위가 한정적이므로 유지보수가 편리해짐

<br/>

cf. Mutater: 상태를 변화시키는 메서드
```java
class HitPoint{
    private static final int MIN = 0;
    int amount;

    HitPoint(final int amount){
        if(amount < MIN){
            throw new IllegalArgumentException();
        }

        this.amount = amount;
    }

    void damage(final int damageAmount){
        final int nextAmount = amount - damageAmount;
        amount = Math.max(MIN, nextAmount);
    }

    boolean isZero(){
        return amount == MIN;
    }
}

class Member{
    final HitPoint hitPoint;
    final States states;

    void damage(final int damageAmount){
        hitPoint.damage(damageAmount);
        if(hitPoint.isZero()){
            states.add(StateType.dead);
        }
    }
}
```



## 5장 응집도: 흩어져 있는 것들
⭐ 응집도: 클래스 내부에서 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표
### 5.1 static 메서드 오용
```java
class OrderManager{
    static int add(int moneyAmount1, int moneyAmount2){
        return moneyAMount1 + moneyAmount2;
    }
}
```
🚨 static 메서드는 인스턴스 변수를 사용할 수 없어, 데이터와 데이터를 조작하는 로직 사이에 괴리가 생겨 응집도가 낮아질 수 있음

```java
class PaymentManager{
    private int discountRate;

    int add(int moneyAmount1, int moneyAmount2){
        return moneyAmount1 + moneyAmount2;
    }
}
```
🚨 인스턴스 변수를 전혀 사용하지 않는 메서드는 static 메서드와 동일한 기능  
→ 메서드 앞에 static 추가 시, 오류가 발생하지 않는다면 인스턴스 메서드인 척 하는 static 메서드

⭐ static 메서드를 사용하면 좋은 상황
* 로그 출력 전용 메서드
* 포맷 전환 전용 메서드
등 응집도와 관계없는 기능

### 5.2 초기화 로직 분산
```java
class GiftPoint{
    private static final int MIN_POINT = 0;
    final int value;

    GiftPoint(final int point){
        if(point < MIN_POINT){
            throw new IllegalArgumentException("포인트를 0 이상 입력해야 합니다.");
        }

        value = point;
    }

    /**
     * 포인트 추가하기
     * 
     * @param other 추가 포인트
     * @return 추가 후 남은 포인트
    */
    GiftPoint add(final GiftPoint other){
        return new GiftPoint(value + other.value);
    }

    /**
     * @return 남은 포인트가 소비 포인트 이상이라면 true
    */
    boolean isEnough(final ConsumptionPoint point){
        return point.value <= value;
    }

    /**
     * 포인트 소비하기
     * 
     * @param point 소비 포인트
     * @return 소비 후 남은 포인트
    */
    GiftPoint consume(final ConsumptionPoint point){
        if(!isEnough(point)){
            throw new IllegalArgumentException("포인트가 부족합니다.");
        }

        return new GiftPoint(value - point.value);
    }
}

GiftPoint standardMembershipPoint = new GiftPoint(3000);
GiftPoint premiumMembershipPoint = new GiftPoint(10000);
```
🚨 생성자를 public으로 만들면, 의도치 않은 용도의 사용으로 관련된 로직이 분산되어 유지보수가 힘들어 질 수 있음

⭐ private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화
```java
class GiftPoint{
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;

    private GiftPoint(final int point){
        if(point < MIN_POINT){
            throw new IllegalArgumentException("포인트는 0이상 이어야 합니다.");
        }

        value = point;
    }

    /**
     * @return 표준 가입 기프트 포인트
    */
    static GiftPoint forStandardMembership(){
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }

    /**
     * @return 프리미엄 가입 기프트 포인트
    */
    static GiftPoint forPremiumMembership(){
        return new GiftPoint(PREMIUM_MEMBERSHIP_POINT);
    }
}

GiftPoint standardMembershipPoint = GiftPoint.forStandardMembership();
GiftPoint premiumMembershipPoint = GiftPoint.forPremiumMembership();
```

🚨 생성 로직이 너무 많아지면 해당 클래스의 하는 일이 불분명해지므로, 생성 전용 팩토리 클래스로 분리하는 방법을 고려

### 5.3 범용 처리 클래스(Common/Util)
```java
class Common{
    // 생략

    static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax, BigDecimal taxRate){
        return amountExcludingTax.multiply(taxRate);
    }
}
```

```java
class AmountIncludingTax{
    final BigDecimal value;

    AmountIncludingTax(final AmountExcludingTax amountExcludingTax, final TaxRate taxRate){
        value = amountExcludingTax.value.multiply(taxRate.value);
    }
}
```

⭐ 꼭 필요한 경우가 아니라면, 범용 처리 클래스를 만들지 않는 것이 좋음
→ 횡단 관심사와 같이 애플리케이션의 모든 동작에 필요한 기능은 범용 코드로 만들어도 좋음
* 로그 출력
* 오류 확인
* 디버깅
* 예외 처리
* 캐시
* 동기화
* 분산 처리 등


### 5.4 결과를 리턴하는 데 매개변수 사용하지 않기
⭐ 매개변수는 입력으로 전달하는 것이 일반적
→ 출력 매개변수 사용 시, 매개변수가 입력인지 출력인지 메서드 내부의 로직을 확인해야 함

```java
class ActorManager{
    void shift(Location location, int shiftX, int shiftY){
        location.x += shiftX;
        location.y += shiftY;
    }
}
```

```java
class Location{
    final int x;
    final int y;

    Location(final int x, final int y){
        this.x = x;
        this.y = y;
    }

    Location shift(final int shiftX, final int shiftY){
        final int nextX = x + shiftX;
        final int nextY = y + shiftY;

        return new Location(nextX, nextY);
    }
}
```

### 5.5 매개변수가 너무 많은 경우
```java
/**
 * 매직 포인트 회복하기
 * @param currentMagicPoint 현재 매직포인트 잔량
 * @param originalMaxMagicPoint 원래 매직포인트 최댓값
 * @param maxMagicPointIncrements 장비로 증가하는 매직포인트 최댓값 증가량
 * @param recoveryAMount 회복량
 * @return 회복 후의 매직포인트 잔량
*/
int recoverMagicPoint(int currentMagicPoint, int originalMaxMagicPoint, List<Integer> maxMagicPointIncrements, int recoveryAmount){
    int currentMaxMagicPoint = originalMaxMagicPoint;
    for(int each : maxMagicPointIncrements){
        currentMaxMagicPoint += each;
    }

    return Math.min(currentMagicPoint, recoveryAmount, currentMaxMagicPoint);
}
```

⭐ 개념적으로 의미 있는 단위는 모두 클래스로 만들기
→ 매개변수가 아니라 인스턴스 변수로 표현하기
```java
class MagicPoint{
    private int currentAmount;
    private int originalMaxAmount;
    private final List<Integer> maxIncrements;

    /**
     * @return 현재 매직 포인트 잔량
    */
    int current(){
        return currentAmount;
    }

    /**
     * @return 매직 포인트 최댓값
    */
    int max(){
        int amount = originalMaxAmount;
        for(int each : maxIncrements){
            amount += each;
        }

        return amount;
    }

    /**
     * 매직 포인트 회복하기
     * @param recoveryAmount 회복량
    */
    void recover(final int recoveryAmount){
        currentAmount = Math.min(currentAmount + recoveryAmount, max());
    }

    /**
     * 매직 포인트 소비하기
     * @param consumeAmount 소비량
    */
    void consume(final int consumeAmount){...}
}
```

### 5.6 메서드 체인
```java
/**
 * 갑옷 입기
 * @param memberId 장비를 변경하고 싶은 멤버의 ID
 * @param newArmor 입을 갑옷
*/
void equipArmor(int memberId, Armor newArmor){
    if(party.members[memberId].equipments.canChange){
        party.members[memberId].equipments.armor = newArmor;
    }
}
```

⭐ 상세한 로직은 호출하는 쪽이 아니라, 호출되는 쪽에 구현하기
```java
/**
 * 장비하고 있는 방어구 목록
*/
class Equipments{
    private boolean canChange;
    private Equipment head;
    private Equipment armor;
    private Equipment arm;

    /**
     * 갑옷 장비하기
     * 
     * @param newArmor 장비할 갑옷
    */
   void equipArmor(final Equipment newArmor){
    if(canChange){
        armor = newArmor;
    }
   }

    /**
     * 전체 장비 해제하기
    */
    void deactiveAll(){
        head = Equipment.EMPTY;
        armor = Equipment.EMPTY;
        arm = Equipment.EMPTY;
    }
}
```
