# 헤드 퍼스트 디자인 패턴

📖 2024.05.11 - 


## 1. 디자인 패턴의 세계로 떠나기: 디자인 패턴 소개와 전략 패턴

`기존`  
Duck
  * quack()
  * swim()
  * display()
  * fly()

MallardDuck
  * display(){...}
RedHeadDuck
  * display(){...}
RubberDuck
  * display(){...}

🚨 문제
  * 추상 클래스에 기능 구현을 하면 상속받는 클래스에서 오버라이딩을 하지 않았을 경우 문제 발생

⭐ 바뀌는 부분과 그렇지 않은 부분을 분리하여 변화하는 부분을 뽑아내기

`변경`  
Duck
  * FlyBehavior flyBehavior
  * QuackBehavior quackBehavior
  * performQuack()
  * swim()
  * display()
  * performFly()

```java
public abstract class Duck{
    QuackBehavior quackBehavior;

    public void performQuack(){
        quackBehavior.quack();
    }
}

public class MallardDuck extends Duck{
    public MallardDuck(){
        quackBehavior = new Quack();
        flyBehavior = new FlyWithWings();
    }

    public void display(){
        System.out.println("저는 물오리입니다🦆");
    }
}
```

`동적으로 행동 지정`  
Duck
  * FlyBehavior flyBehavior
  * QuackBehavior quackBehavior
  * swim()
  * display()
  * performQuack()
  * performFly()
  * setFlyBehavior()
  * setQuackBehavior()

```java
public void setFlyBehavior(FlyBehavior fly){
    flyBehavior = fly;
}
public void setQuackBehavior(QuackBehavior quack){
    quackBehavior = quack;
}

Duck duck = new ModelDuck();
duck.performFly(); // 생성자에서 설정된 flyBehavior가 호출됨
duck.setFlyBehavior(new FlyRocketPowered()); // flyBehavior 새로 설정
duck.performFly(); // setFlyBehavior에서 설정된 flyBehavior가 호출됨
```

`전략 패턴(Strategy Pattern)`  
알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함  
전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음



## 2. 객체들에게 연락 돌리기: 옵저버 패턴

`옵저버 패턴(Observer Pattern)`  
한 객체가 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의함

```java
public interface Subject{
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}

public interface Observer{
    public void update(float temp, float humidity, float pressure)
    // 정보가 변경되었을 때 Observer에게 전달되는 상태값들
    // Observer 인터페이스는 모든 옵저버 클래스에서 구현해야하므로 update()도 필수 구현
}

public interface DisplayElement{
    public void display();
}

public class WeatherData implements Subject{
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData(){
        observers = new ArrayList<Observer>();
    }

    public void registerObserver(Observer o){
        observers.add(o)
    }

    public void removeObserver(Observer o){
        observers.remove(o)
    }

    public void notifyObservers(){
        for(Observer o : observers){
            o.update(temperature, humidity, pressure);
        }
    }

    public void measurementsChanged(){
        notifyObservers();
    }

    public void setMeasurements(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;

        measurementsChanged();
    }
}

public class CurrentConditionsDisplay implements Observer, DisplayElement(){
    private float temperature;
    private float humidity;
    private WeatherData weatherData;

    public CurrentConditionsDisplay(WeatherData weatherData){
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    public void update(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }

    public void display(){
        System.out.println("온도: " + temperature + ", 습도: " + humidity);
    }
}

public class WeatherStation{
    public static void main(String[] args){
        WeatherData weatherData = new WeatherData();

        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);

        weatherData.setMeasurements(80, 65, 30.4f);
        weatherData.setMeasurements(82, 70, 29.9f);
        weatherData.setMeasurements(78, 90, 29.2f);
    }
}
```

변경이 발생하면 값을 보내주는 `Push 방식`에서 변경을 알라면 옵저버가 필요한 값을 가져오는 `Pull 방식`으로 변경
```java
// WeatherData
public void notifyObservers(){
    for(Observer o : observers){
        o.update();
    }
}

public interface Observer{
    public void update();
}

// CurrentConditionsDisplay
public void update(){
    this.temperature = weatherData.getTemperature();
    this.humidity = humidity.getHumidity();
    display();
}

```

🤓 예시
  * C#: INotifyPropertyChanged
    * WPF에서 주로 데이터 바인딩 시에 프로퍼티 값이 변경될 때마다 UI에 변경 사항을 자동으로 알리기 위해 사용



## 3. 객체 꾸미기: 데코레이터 패턴

⭐ OCP를 지키다 보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데, 추상화를 하다 보면 코드가 복잡해짐 → 그래서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋음
















































































































































































































































































































































































































































































































































































































































































































































































































































































































