# 정보처리기사

## IP 주소 체계
- IPv4
    - 주소 길이: 32bit (8bit*4)
    - 주소 개수: 2^32개
    - 주소 할당: A, B, C 클래스 등 비순차적 할당
    - 주소 체계: 유니캐스트(1:1), 멀티캐스트(1:다), 브로드캐스트(방송)
    - 보안: IPSec, SSL(HTTPS), S-HTTP Protocol 별도 설치
- IPv6
    - 주소 길이: 128bit (16bit*8)
    - 주소 개수: 2^128
    - 주소 할당: 순차적 할당
    - 주소 체계: 유니캐스트(1:1), 멀티캐스트(1:다), 애니캐스트(가장 자까운 수신자에게 전달)
    - 보안: 자체 보안기능 제공

<br/>

## C언어 비트 논리연산자
|연산자|설명|
|-|-|
|&|두 비트가 모두 참이면 참|
|\||두 비트 중 하나라도 참이면 참|
|^|두 비트가 서로 다르면 참|
|~|비트의 반전|

## OSI 7 Layer Model
1. 물리 계층(Physical Layer)
    - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
    - 단위: 비트
    - 주요 장비: 허브, 리피터 등
2. 데이터 링크 계층(Data Link Layer)
    - <b>인접 노드 간</b> 프레임 전송, 신뢰성 있는 정보 전달
    - 단위: 프레임
    - 주요 장비: 스위치, 브릿지 등
3. 네트워크 계층(Network Layer)
    - 단말기 간 데이터 전송을 위한 최적화된 경로 제공
    - 단위: 패킷
    - 주요 장비: 라우터 등
    - 프로토콜
        - IP: 데이터 전달
        - ICMP: IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜
        - ARP: 논리 주소인 IP 주소 ▶ 실제적인 물리 주소인 MAC 주소로 변환
        - RARP: 실제적인 물리 주소인 MAC 주소 ▶ 논리 주소인 IP 주소로 변환
4. 전송 계층(Transport Layer)
    - <b>단말기(종단)</b> 간의 연결. 신뢰성 있는 정보 전달
    - 단위: 세그먼트(TCP)/데이터그램(UDP)
    - 프로토콜
        - TCP
            - FTP(20-데이터, 21-제어): 파일 전송
            - telnet(23): 원격지의 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜
            - HTTP(80): 웹 서비스
            - SMTP(25): 메일 송신
            - POP3(110): 메일 수신
        - UDP
            - DHCP: IP 자동 할당
            - SNMP: 네트워크 관리
            - DNS(53): 도메인 ▶ IP 주소로 변환
5. 세션 계층(Session Layer)
    - 송수신 간의 논리적 연결
    - 단위: 데이터
6. 표현 계층(Presentation Layer)
    - 데이터 형식 설정, 암/복호화
    - 단위: 데이터
7. 응용 계층(Application Layer)
    - 일반적인 응용 서비스를 수행
    - 단위: 데이터

<br/>

## 응집도
: 모듈 내부의 기능적인 집중 정도

1. 우연적(Coincidental): 모듈 내부의 각 구성요소들이 연관이 없을 경우
2. 논리적(Logical): 유사한 성격을 갖는 요소들이 한 모듈에서 처리
3. 시간적(Temporal): 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
4. 절차적(Procedural): 모듈 안의 구성요소들이 그 기능을 순차적으로 수행
5. 통신적(Communicational): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
6. 순차적(Sequential): 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
7. 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

## 결합도
: 모듈과 모듈간의 상호 의존 정도

1. 자료(Data): 파라미터로 값만을 전달하는 경우
2. 스탬프(Stamp): 파라미터로 배열이나 오브젝트, 스트럭쳐 등의 객체가 전달되는 경우
3. 제어: 파라미터로 값뿐만 아니라 제어 요소도 전달되는 경우
4. 외부(External): 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우
5. 공통(Common): 공유되는 공통 데이터 영역(<b>전역변수</b>)을 여러 모듈이 사용하는 경우
6. 내용(Content): 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정하는 경우

<br/>

## 교착상태 발생 조건
1. 상호배제(Mutual Exclusion): 한 프로세스가 사용중일 경우, 다른 프로세스 사용 불가
2. 점유 및 대기(Hold and Wait): 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 대기
3. 비선점(Non-Preemption): 다른 프로세스가 점유중인 자원을 강제로 획득 불가
4. 환형대기(Circulation Wait): 점유 및 대기가 순환구조를 이루고 있음

## 교착상태 해결 방법
- 예방: 발생 조건을 억제
- 회피: 은행원 알고리즘

<br/>

## Shell & Kernel
- Shell
    - 사용자와 운영체제간에 대화를 가능하게 해주는 명령어 해석기 역할
    - 사용자와 내부 커널 사이의 인터페이스 역할
- Kernel
    - 리눅스 운영체제의 핵심
    - 소프트웨어로부터의 요청을 하드웨어(CPU, 메모리, 저장장치등)가 처리 할 수 있도록 요청을 변환하는 역할을 수행

<br/>

## 프로세스 상태 종류
<img src="https://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png" alt="process_state" width="100%">

<br/>

## 프로세스 스케쥴링
: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업

1. 비선점(Non-Preemptive): 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
    - FCFS: First Come First Served, 
    - SJF: Shortest Job First
        - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
        - 단점: 기아 현상 발생 ▶ 대안: HRN
    - HRN: Hightest Response-ratio Next
        - 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
        - 우선순위 = (대기 시간 + 실행 시간)/(실행 시간)
    - 우선순위
    - 기한부
2. 선점(Preemptive): 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
    - Round Robin: 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
    - SRT: Shortest Remaining Time, SJF의 선점형 버전
    - MLQ(다단계 큐): 각 작업들을 서로 다른 묶음으로 분류할 수 있을 때 사용하는 알고리즘
        - 예: 쇼핑몰에서 쇼핑은 빠르게 백그라운드에서는 다운로드는 느리게
    - MFQ(다단계 피드백 큐)
        - 그룹화 된 큐마다 실행 시간을 달리 부여하여 시간 내 실행이 완료되지 않을 경우 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
        - 프로세스 성격에 따라 적응적 스케줄링이 가능

<br/>

## LAN 802.X
- 802.3: CSMA/CD, 유선랜 충돌 감지
- 802.11: CSMA/CA, 무선랜 충돌 회피
- 802.4: 토큰 버스
- 802.5: 토큰 링
- 802.15: 블루투스

<br/>

## 언어
### 번역기
- Compiler
    - 짜여진 소스코드 전체를 한번에 번역
    - Java, C, C++ 등을 번역할 때 사용
- Interpreter
    - 명령 하나하나 실행할 때마다 번역
    - Python, Perl 등을 번역할 때 사용
- Assembler
    - assembly어를 기계어로 번역

### 종류
- 컴파일 언어
    - C, C++, Go 등
    - 번역과 실행이 완전히 따로 이루어짐
    - 컴파일은 오래 걸리지만, 실행 시간은 빠름
- 인터프리터(스크립트) 언어
    - JavaScript, Python, PHP 등
    - 번역과 실행을 동시에 진행
    - 실행이 느림
    - 디버깅이 쉬워 개발의 편의성이 높음
- cf. Java: 하이브리드언어
    - 컴파일 언어: *.java → *.class
    - 인터프리터 언어: *.class → 이진 코드

<br/>

## 기억 장치 배치 전략
1. 최초 적합 기법(first-fit strategy)
: 주기억장치의 첫 번째 유용한 공백을 우선적으로 선택하는 방법
2. 최적 적합 기법(best-fit strategy)
: 가장 적합한 공간을 선택함으로써 기억장치의 단편화를 최소로 하는 방법
3. 최악 적합 기법(worst-fit strategy)
: 프로그램을 주기억장치 내에서 가장 알맞지 않은 공백, 즉 가장 큰 공백에 배치하는 방법

<br/>

## 가상기억장치 구현 시, 성능과 관련된 요소
1. 페이지 크기
2. 지역성: 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조
3. 워킹 셋: 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
    - 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상을 줄일 수 있음
4. 페이지 부재 빈도: 페이지 부재가 일어나는 횟수
5. 프리페이징: 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재
6. 스레싱(Thrashing): 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

<br/>

## Paging
: 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식 → 마지막 페이지에 내부 단편화가 발생
## Segmentation
: 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당 → 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생

## 페이지 교체 알고리즘
: 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(= 페이징 부재) 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법

1. FIFO(first in first out)
: 가장 간단한 알고리즘, 메모리에 올라온 지 가장 오래된 페이지를 교체
2. SCR(Second Chance Replacement)
: FIFO에서 한 번 더 기회를 주고 교체
3. 최적(Optimal)
: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 - 구현 불가능
4. LRU(least-recently-used)
: 가장 오래 사용되지 않은 페이지를 교체
5. NUR(Not Used Recently)
: 최근에 사용하지 않은 페이지 교체
6. LFU(least-frequently-used)
: 참조 횟수가 가장 작은 페이지를 교체
7. MFU(most-frequently-used)
: 참조 횟수가 가장 많은 페이지를 교체

<br/>

## Java 접근제한자
||public|protected|default|private|
|-|-|-|-|-|
|동일 클래스|O|O|O|O|
|동일 패키지|O|O|O||
|다른 패키지의 자식 클래스|O|O|||
|다른 패키지|O||||

<br/>

#### 변수 선언
```
int c;

c - 일반적으로 garbage value가 들어있음
예외적으로 0이 입력되어있는 경우
    - static value
    - 배열의 빈 값
```
