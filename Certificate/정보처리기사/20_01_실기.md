# 정보처리기사 실기

## 1. 반정규화
DB 정규화 이후, `성능 향상`을 위해 의도적으로 정규화 기법에 위배되어 데이터를 중복하여 저장하는 방법

### 데이터 모델링 3단계
1. 개념
    - ERD 생성
2. 논리
    - 정규화
    - Transaction Interface 설계
3. 물리
    - 성능 향상(인덱스, 파티션, 반정규화 등)

### 정규화
- 데이터의 중복을 방지하고, 무결성을 보장하기 위한 DB 설계 방법
- 삽입 이상이나 갱신 이상 등 다양한 이상 현상(정보를 정확하게 검색하거나 조작할 수 없는 상태)을 제거할 수 있음

<br/>

## 2. Markup Language
`XML`

### Markup Language
HTML: 태그가 정해져 있어 데이터 전송이 어려움
→ SGML: 사용이 어려움
→ XML: 확장형 마크업 언어, 기본 태그 및 커스터마이징한 태그 사용 가능

### 인터페이스 전송 데이터
- JSON(JavaScript Object Notation)
    - {Key: Value} 형태
- XML(eXtensible Markup Language)
    - 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어
- CSV(Comma Separated Values)
    - 몇 가지 필드를 쉼표로 구분한 텍스트 데이터
- YAML
    - 사람이 쉽게 읽을 수 있는 데이터 직렬화 양식

<br/>

## 3. 살충제 패러독스(Pesticide Paradox)
동일한 테스트 케이스로 동일한 절차를 반복 수행하면 새로운 결함을 찾을 수 없다.

### SW 테스트 방법
- 결함 집중(파레토 법칙)
    - 대다수의 결함은 소수의 특정 모듈에 집중되는 경향이 있다.
- 살충제 패러독스
    - 동일한 테스트 케이스를 반복적으로 수행하는 경우 더 이상 새로운 결함을 찾아낼 수 없다.
- 오류-부재의 궤변
    - 거의 모든 결함을 확인 후 제거하였다고 해도 사용자의 요구 또는 비즈니스 목적을 충족시키지 못하는 경우 품질이 높다고 할 수 없다.

<br/>

## 4. 결합도(Coupling), 응집도(Cohesion)
모듈의 독립성을 판단하는 두 가지 지표로, `결합도(Coupling)`는 모듈과 모듈간의 상호 의존 정도, `응집도(Cohesion)`는 모듈 내부의 기능적인 집중 정도이다.

### 결합도(Coupling)
: 모듈과 모듈간의 상호 의존 정도
1. 자료(Data): 파라미터로 값만을 전달하는 경우
2. 스탬프(Stamp): 파라미터로 배열이나 오브젝트, 스트럭쳐 등의 객체가 전달되는 경우
3. 제어: 파라미터로 값뿐만 아니라 제어 요소도 전달되는 경우
4. 외부(External): 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우
5. 공통(Common): 공유되는 공통 데이터 영역(<b>전역변수</b>)을 여러 모듈이 사용하는 경우
6. 내용(Content): 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정하는 경우
    - 내용 결합도가 높을 경우, 스파게티 코드가 될 수 있음

- Spaghetti Code: 소스 코드가 복잡하게 얽힌 경우
- Alien Code: 아주 오래되거나 참고문서가 없어 유지보수가 어려운 경우
- Legacy Code: 더 이상 쓰기 힘들고 난해한 경우

### 응집도(Cohesion)
: 모듈 내부의 기능적인 집중 정도
1. 우연적(Coincidental): 모듈 내부의 각 구성요소들이 연관이 없을 경우
2. 논리적(Logical): 유사한 성격을 갖는 요소들이 한 모듈에서 처리
3. 시간적(Temporal): 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
4. 절차적(Procedural): 모듈 안의 구성요소들이 그 기능을 순차적으로 수행
5. 통신적(Communicational): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
6. 순차적(Sequential): 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
7. 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

<br/>

## 5. Fan-in / Fan-out
Fan-in: 나를 누구가가 호출하는 것
Fan-out: 내가 누군가를 호출하는 것

<br/>

## 6. JSON
- JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위해 사용
- 최근 XML을 대체해서 데이터 전송 등에 많이 사용됨
- 데이터 형식: {Key: Value}

<br/>

## 7. 성능 측정 지표
- `처리량(Throughput)`: 일정 시간 내에 애플리케이션이 처리하는 일의 양
- `응답 시간(Response Time)`: 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
- `경과 시간(Turn Around Time)`: 애플리케이션에 요청을 전달한 시간부터 처리 완료될 때까지 걸린 시간

<br/>

## 8. DISTINCT
- SELECT DEPT FROM STUDENT; // 200
- SELECT DISTINCT DEPT FROM STUDENT; // 3
- SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT='건축과'; // 1

### SELECT문 작성 순서
(SELECT) (FROM) (WHERE) (GROUP BY) (HAVING) (ORDER BY)

<br/>

## 9. 서비스 공격
`Land Attack`: Packet의 보내는 사람과 받는 사람을 동일하게 설정하여 자신의 서버를 계속 돌면서 서버의 자원을 고갈시켜 `가용성`을 파괴

### 정보보안의 3요소
- 기밀성: 인가된 사용자만 접근
- 무결성: 인가된 사용자만 인가된 방법으로 자원 수정
- 가용성: 인가된 사용자는 언제든지 접근 가능

### Dos(Denial of Service)
- Ping Of Death: 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화된 패킷을 처리하게 만드는 공격
- Smurf: IP를 위조하여 ICMP 받을 대상에 과부하
- Land Attack: Packet의 보내는 사람과 받는 사람을 동일하게 설정
- Teardrop Attack: Fragment를 재조립 시 정확한 조립을 위해 오프셋이라는 값을 더하게 되는데 이 오프셋 값을 고의적으로 수정하여 시스템의 기능을 마비시켜 버리는 방법
- SYN Flooding: 접속을 요청하는 SYN Packet을 대량으로 전송해 네트워크를 마비 시킴
- UDP Flooding: 많은 수의 UDP packet을 전송하여 정상적인 서비스가 불가능하도록 하는 공격
- Ping Flooding: 많은 ICMP Echo를 보내 이에 대한 응답을 하기 위해 자원을 모두 사용해버려 시스템이 정상적으로 동작하지 못하도록 하는 공격

### DDoS (Distributed Denial of Service)
- Phishing: 공격자가 사람들을 속여 사기에 빠지도록 고안된 악성 이메일을 보내는 것
- Pharming: 피싱 기법 중 하나로, 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인정보를 훔치는 것
- Sniffing: 네트워크 중간에서 남의 패킷 정보를 도청하는 것
- Smishing: SMS와 Phishing의 결합어로 문자메시지를 이용한 피싱
- Qshing: QR코드와 피싱(Phishing)의 합성어로 QR코드를 이용한 피싱
- Ransomware: 컴퓨터 시스템을 감염시켜 접근을 제한하고 일종의 몸값을 요구하는 악성 소프트웨어
- Key Logger: 컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격
- SQL Injection: 임의로 작성한 SQL 구문을 애플리케이션에 삽입하는 공격 방식
- XSS(Cross Site Scripting): 악의적인 스크립트를 포함하여 정보 유출 등의 공격을 하는 것

### 기타
- Rainbow Table Attack: 해시함수에 입력한 값과 해시값을 저장한 일종의 정답지를 갖고 일치하는 해시값을 통해 Key 값을 찾는 방식
    - Salt: 해커들의 레인보우 테이블이 키 값에 대한 해시값을 갖고 있으므로, 해당 값에 다른 값을 덧붙여서 다른 암호 값으로 저장되도록 추가하는 값

<br/>

## 10. 통신 프로토콜의 기본요소 3가지
- `구문(Syntax)`: 데이터의 구조나 형태를 정의
- `타이밍(Tining)`
- `의미(Semantic)`

<br/>

## 11. HRN(Highest Response-ratio Next)
= `(대기 시간 + 서비스 시간) / 서비스 시간`

### 프로세스 스케쥴링
: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업

1. 비선점(Non-Preemptive): 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
    - FCFS: First Come First Served, 
    - SJF: Shortest Job First
        - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
        - 단점: 기아 현상 발생 ▶ 대안: HRN
    - HRN: Hightest Response-ratio Next
        - 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
        - 우선순위 = (대기 시간 + 실행 시간)/(실행 시간)
    - 우선순위
    - 기한부
2. 선점(Preemptive): 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
    - Round Robin: 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
    - SRT: Shortest Remaining Time, SJF의 선점형 버전
    - MLQ(다단계 큐): 각 작업들을 서로 다른 묶음으로 분류할 수 있을 때 사용하는 알고리즘
        - 예: 쇼핑몰에서 쇼핑은 빠르게 백그라운드에서는 다운로드는 느리게
    - MFQ(다단계 피드백 큐)
        - 그룹화 된 큐마다 실행 시간을 달리 부여하여 시간 내 실행이 완료되지 않을 경우 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
        - 프로세스 성격에 따라 적응적 스케줄링이 가능

<br/>

## 12. 트랜젝션 성질
1. 원자성(Atomicity): Commit, Rollback
2. 일관성(Consistency): 무결성
3. 격리성(Isolation)
4. 영속성(Durability)

<br/>

## 13. OSI 7 Layer Model
1. 물리 계층(Physical Layer)
    - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
    - 단위: 비트
    - 주요 장비: 허브, 리피터 등
2. 데이터 링크 계층(Data Link Layer)
    - <b>인접 노드 간</b> 프레임 전송, 신뢰성 있는 정보 전달
    - 단위: 프레임
    - 주요 장비: 스위치, 브릿지 등
3. 네트워크 계층(Network Layer)
    - 단말기 간 데이터 전송을 위한 최적화된 경로 제공
    - 단위: 패킷
    - 주요 장비: 라우터 등
    - 프로토콜
        - IP: 데이터 전달
        - ICMP: IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜
        - ARP: 논리 주소인 IP 주소 ▶ 실제적인 물리 주소인 MAC 주소로 변환
        - RARP: 실제적인 물리 주소인 MAC 주소 ▶ 논리 주소인 IP 주소로 변환
4. 전송 계층(Transport Layer)
    - <b>단말기(종단)</b> 간의 연결. 신뢰성 있는 정보 전달
    - 단위: 세그먼트(TCP)/데이터그램(UDP)
    - 프로토콜
        - TCP
            - FTP(20-데이터, 21-제어): 파일 전송
            - telnet(23): 원격지의 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜
            - HTTP(80): 웹 서비스
            - SMTP(25): 메일 송신
            - POP3(110): 메일 수신
        - UDP
            - DHCP: IP 자동 할당
            - SNMP: 네트워크 관리
            - DNS(53): 도메인 ▶ IP 주소로 변환
5. 세션 계층(Session Layer)
    - 송수신 간의 논리적 연결
    - 단위: 데이터
6. 표현 계층(Presentation Layer)
    - 데이터 형식 설정, 암/복호화
    - 단위: 데이터
7. 응용 계층(Application Layer)
    - 일반적인 응용 서비스를 수행
    - 단위: 데이터

<br/>

## 15. Data Mining
수많은 데이터에서 가치있는 유용한 정보를 찾아내는 것

<br/>

## 16. 암호화 알고리즘
MD5: MD4를 개선한 알고리즘

- 단방향(Hash): MD ▶ SHA
- 양방향
    - 대칭키
        - 빠른 속도
        - 많은 양
        - 키 개수: n*(n-1)/2
        - 종류
            - Stream: RC4
            - Block: DES ▶ AES, IDEA, SEED, ARIA
    - 비대칭키(공개키)
        - 느린 속도
        - 적은 양 ◀ 내용보다는 키를 암호화하는 방식으로 사용
        - 키 개수: 2*n
        - 종류
            - 소인수분해: RSA, Robin
            - 이산대수: DH, DSA, EIGmal
            - 타원곡선: ECC, ECDSA

<br/>

## 18. C 언어
```
int a[] = {95, 75, 85, 100, 50};
int i, j, temp;
int n = sizeof(a) / sizeof(int);
// sizeof(a): 배열 a의 전체 크기를 바이트 단위로 반환
// sizeof(int): int 데이터 형식의 크기를 바이트 단위로 반환
// sizeof(a) =  20바이트(5개의 int 요소 * 각각 4바이트)
// sizeof(int) =  일반적으로 4바이트
// sizeof(a) / sizeof(int) = 5, 배열에 저장된 요소의 개수 반환

for(i=0; i<n-1; i++){
    for(j=0; j<4-i; j++){
        if(a[j]>a[j+1]){
            temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
        }
    }
}

// 버블 정렬
// 이전 요소가 다음 요소보다 더 크다면 다음 요소값을 이전 요소에 대입
// 가장 큰 값이 가장 마지막에 위치되므로 반복문이 진행될수록 큰 값은 더 이상 정렬하지 않아도 됨
// i = 0, j = (0, 1), (1, 2), (2, 3), (3, 4)
// i = 1, j = (0, 1), (1, 2), (2, 3)
// i = 2, j = (0, 1), (1, 2)
// i = 3, j = (0, 1)

for(i=0; i<5; i++){
    printf("%d", a[i]);
}
```

<br/>

## 20. Java
`Switch문은 break를 만나기 전까지 계속 실행됨`

```
int i = 3, c = 1;

switch i {
    case 1: c++;
    case 2: c += 3;
    case 3: c = 0; // 0
    case 4: c += 3; // 3
    case 5: c -= 10; // -7
    default: c--; // -8
}

System.out.print(c); // -8
```
