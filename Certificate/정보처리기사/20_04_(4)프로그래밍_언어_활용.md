# 정보처리기사

## Shell & Kernel
- Shell
    - 사용자와 운영체제간에 대화를 가능하게 해주는 명령어 해석기 역할
    - 사용자와 내부 커널 사이의 인터페이스 역할
- Kernel
    - 리눅스 운영체제의 핵심
    - 소프트웨어와 하드웨어간의 입출력 관리
    - 소프트웨어로부터의 요청을 하드웨어(CPU, 메모리, 저장장치등)가 처리 할 수 있도록 요청을 변환하는 역할을 수행

### Shell 환경 변수 출력 명령어
- env
- printenv
- setenv
- export

<br/>

## OSI 7 Layer Model
1. 물리 계층(Physical Layer)
    - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
    - 단위: 비트
    - 주요 장비: 허브, 리피터 등
2. 데이터 링크 계층(Data Link Layer)
    - <b>인접</b> 노드 간 프레임 전송, 신뢰성 있는 정보 전달
    - 단위: 프레임
    - 주요 장비: 스위치, 브릿지 등
3. 네트워크 계층(Network Layer)
    - 단말기 간 데이터 전송을 위한 최적화된 경로 제공
    - 단위: 패킷
    - 주요 장비: 라우터 등
    - 프로토콜
        - IP: 데이터 전달
        - ICMP: IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜
        - ARP: 논리 주소인 IP 주소 ▶ 실제적인 물리 주소인 MAC 주소로 변환
        - RARP: 실제적인 물리 주소인 MAC 주소 ▶ 논리 주소인 IP 주소로 변환
4. 전송 계층(Transport Layer)
    - <b>단말기(종단)</b> 간의 연결. 신뢰성 있는 정보 전달
    - 단위: 세그먼트(TCP)/데이터그램(UDP)
    - 프로토콜
        - TCP
            - FTP(20-데이터, 21-제어): 파일 전송
            - telnet(23): 원격지의 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜
            - HTTP(80): 웹 서비스
            - SMTP(25): 메일 송신
            - POP3(110): 메일 수신
        - UDP
            - DHCP: IP 자동 할당
            - SNMP: 네트워크 관리
            - DNS(53): 도메인 ▶ IP 주소로 변환
5. 세션 계층(Session Layer)
    - 송수신 간의 논리적 연결
    - 단위: 데이터
6. 표현 계층(Presentation Layer)
    - 데이터 형식 설정, 암/복호화
    - 단위: 데이터
7. 응용 계층(Application Layer)
    - 일반적인 응용 서비스를 수행
    - 단위: 데이터

<br/>

## Python-Slice
arr[a : b : c]
- a: 시작 위치
- b: 끝 위치(해당 위치 제외)
- c: 증감 단위

<br/>

## 프로세스 스케쥴링
: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업

1. 비선점(Non-Preemptive): 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
    - FCFS: First Come First Served, 
    - SJF: Shortest Job First
        - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
        - 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태(기아 현상)가 발생 ▶ (대안) HRN
    - HRN: Hightest Response-ratio Next
        - 대기 시간과 서비스(실행) 시간을 이용하는 기법
        - 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
        - (대기 시간 + 실행 시간)/(실행 시간)
    - 우선순위
    - 기한부
2. 선점(Preemptive): 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
    - Round Robin: 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
    - SRT: Shortest Remaining Time, SJF의 선점형 버전
    - MLQ(다단계 큐): 각 작업들을 서로 다른 묶음으로 분류할 수 있을 때 사용하는 알고리즘
        - 예: 쇼핑몰에서 쇼핑은 빠르게 백그라운드에서는 다운로드는 느리게
    - MFQ(다단계 피드백 큐)
        - 그룹화 된 큐마다 실행 시간을 달리 부여하여 시간 내 실행이 완료되지 않을 경우 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
        - 프로세스 성격에 따라 적응적 스케줄링이 가능

<br/>

## TCP-흐름제어
: 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- Sliding Window: 수신 측에서 설정한 윈도우 크기만큼은 송신 측에서 확인 응답ACK를 받기 전에 전송 가능

## TCP-오류제어
: 훼손된 패킷을 감지 하고 중복 수신된 확인 후 폐기하며, 손실된 패킷은 재전송하고 순서에 맞지 않는 세그먼트를 버퍼에 저장하는 기법
- ARQ(자동반복 요청방식)
    - Stop-and-Wait ARQ
    : 수신측으로부터 ACK을 받을 때까지 대기하다가 전송하는 방법
    - Go-back-N ARQ
    : 오류가 난 지점부터 전송한 지점까지 모두 재전송 하는 기법
    - Selective Repeat ARQ
    : 오류가 난 부분만 재 전송하는 기법
    - Adaptive ARQ
    : 전송 효율을 최대한 높이기 위해 데이터 프레임의 길이를 동적으로 변경하여 전송

<br/>

## 응집도
: 모듈 내부의 기능적인 집중 정도

1. 우연적(Coincidental): 모듈 내부의 각 구성요소들이 연관이 없을 경우
2. 논리적(Logical): 유사한 성격을 갖는 요소들이 한 모듈에서 처리
3. 시간적(Temporal): 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
4. 절차적(Procedural): 모듈 안의 구성요소들이 그 기능을 순차적으로 수행
5. 통신적(Communicational): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
6. 순차적(Sequential): 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
7. 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

## 결합도
: 모듈과 모듈간의 상호 의존 정도

1. 자료(Data): 파라미터로 값만을 전달하는 경우
2. 스탬프(Stamp): 파라미터로 배열이나 오브젝트, 스트럭쳐 등의 객체가 전달되는 경우
3. 제어: 파라미터로 값뿐만 아니라 제어 요소도 전달되는 경우
4. 외부(External): 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우
5. 공통(Common): 공유되는 공통 데이터 영역(<b>전역변수</b>)을 여러 모듈이 사용하는 경우
6. 내용(Content): 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정하는 경우

<br/>

||TCP|UDP|
|-|-|-|
|연결 방식|연결형(3-way handshake)|비 연결형|
|전송 순서|보장|보장 X|
|수신 여부 확인|O|X|
|신뢰성|높음|낮음|
|속도|느림|빠름|
|사용 예시|이메일, 파일 전송 등|속도가 중요한 서비스인 스트리밍 등|

<br/>

## Paging
: 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식 → 마지막 페이지에 내부 단편화가 발생

## Segmentation
: 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당 → 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생
