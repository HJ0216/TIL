<!DOCTYPE html>
<html>
<body>
    <div id="root"></div>
</body>

<!--ReactJS 설치 전 script import -->
<script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
<!--React: application의 interactiveness를 올려주는 lib-->
<script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
<!--React DOM: React element를 HTML에 삽입-->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<!--JSX 사용을 위해 import-->
<script type="text/babel;">
/*
    const root = document.getElementById("root");
    let counter = 0;
    function countUp() {
        counter = counter + 1;
        render(); // rerendering
    }
    function render() {
        ReactDOM.render(<App />, root);
    }
    const App = () => (
        <div>
            <h3>Total clicks: {counter}</h3>
            // JS를 사용할 때는 body와 span tag가 업데이트되지만,
            // React를 사용할 때에는 counter만 업데이트됨(Container Component 전체를 재 생성하는 것이 아님)
            <button onClick={countUp}>Click me</button>
        </div>
    );
    render();
    // rendering을 최초에 1회만 할 경우, counter가 UI에 update되지 않는 문제 발생
*/


// rendering 함수를 만들어서 rerendering을 할 경우, 추가적인 작업이 필요한 불편함 발생

const root = document.getElementById("root");
const App = () => {
    
    // const data = React.useState(0);
    // console.log(data);
    // data: [0, f()], 0: state 초기값, f(): state를 변화시킬 수 있는 함수

    // const [counter, setCounter] = [0, f()] : Array 생성 및 변수 할당
    const [counter, setCounter] = React.useState(0);
    const onClick = () => {
        // setCounter(counter+1);
        // setCounter(): counter 업데이트 ▶ useState: rendering 진행
        // * 비동기적 작동을 하는 setter 함수는 현재 상태를 보장하지 않으므로 이전 상태값에서 업데이트를 수행하게되는 문제가 발생할 수 있음
        // current를 통해 현재 counter값을 보장하는 방식으로 업데이트를 진행하는 것이 안전
        setCounter((current) => current + 1);

    }

    return (
        <div>
            <h3>Total clicks: {counter}</h3>
            <button onClick={onClick}>Click me</button>
        </div>    
    );

}
ReactDOM.render(<App />, root);


</script>

</html>
