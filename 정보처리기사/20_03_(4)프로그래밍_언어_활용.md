# 정보처리기사

## SW 보안 취약점
### 메모리
- 버퍼 오버플로우: 메모리 오류가 발생하여 잘못된 동작을 하는 경우 발생
- 허상 포인터: 유효한 객체를 가리키고 있지 않은 포인터로 인해 발생
- Null Pointer 역참조: Null 설정된 변수의 주소값 참조 시 발생

### 입력확인 오류
- 포캣 버그: 검사되지 않은 사용자의 입력
- SQL 삽입: 입력값으로 SQL문을 삽입한 경우
- XSS(Cross Site Scripting): 웹 브라우저에서 의도하지 않은 악성 스크립트가 실행되는 것

<br/>

## IP 주소 체계
- IPv4
    - 주소 길이: 32bit (8bit*4)
    - 헤더 길이: (가변) 20-60byte
    - 주소 개수: 2^32개
    - 주소 체계: 유니캐스트(1:1), 멀티캐스트(1:다), 브로드캐스트(방송) 
    - 보안: IPSec, SSL, S-HTTP Protocol 별도 설치
- IPv6
    - 주소 길이: 128bit (16bit*8)
    - 헤더 길이: (고정) 40byte
    - 주소 개수: 2^128
    - 주소 체계: 유니캐스트(1:1), 멀티캐스트(1:다), 애니캐스트(가장 자까운 수신자에게 전달)
    - 보안: 자체 보안기능 제공

<br/>

## 프로세스 스케쥴링
: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업

1. 비선점(Non-Preemptive): 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
    - FCFS: First Come First Served, 
    - SJF: Shortest Job First
        - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
        - 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태(기아 현상)가 발생 ▶ (대안) HRN
    - HRN: Hightest Response-ratio Next
        - 대기 시간과 서비스(실행) 시간을 이용하는 기법
        - 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
        - (대기 시간 + 실행 시간)/(실행 시간)
    - 우선순위
    - 기한부
2. 선점(Preemptive): 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
    - Round Robin: 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
    - SRT: Shortest Remaining Time, SJF의 선점형 버전
    - MLQ(다단계 큐): 각 작업들을 서로 다른 묶음으로 분류할 수 있을 때 사용하는 알고리즘
        - 예: 쇼핑몰에서 쇼핑은 빠르게 백그라운드에서는 다운로드는 느리게
    - MFQ(다단계 피드백 큐)
        - 그룹화 된 큐마다 실행 시간을 달리 부여하여 시간 내 실행이 완료되지 않을 경우 프로세스에 CPU를 넘겨주고 큐의 뒤로 배치
        - 프로세스 성격에 따라 적응적 스케줄링이 가능

<br/>

## 배치 프로그램 필수 요소
- 대용량 데이터: 대용량 데이터를 처리할 수 있어야 함
- 자동화: 사용자 개입없이 동작해야 함
- 견고함: 비정상적인 동작 중단이 발생하지 않아야 함
- 안정성: 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 함
- 성능

<br/>

## TCP Header
<img src="https://itwiki.kr/images/c/cf/TCP_%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%97%A4%EB%8D%94.jpg" alt="tcp_header" width="100%">

- Source Port: 세그먼트의 출발지를 나타내는 전송 포트
- Destination Port: 세그먼트의 목적지를 나타내는 수신 포트
- Sequence Number: 전송하는 데이터 순서, 수신 측에서 Sequence Number로 순서를 파악해서 다시 올바른 순서로 재조립
- Acknowledge Number: 다음에 수신될 것으로 예상되는 세그먼트의 번호
- Header Length(4): HLEN, 데이터가 시작되는 위치가 어디인지를 나타내서 이 값을 통해 데이터의 시작 위치를 알 수 있음
- Reserve(6): 미래를 위해 남겨놓는 필드
- Flag Bits(6): 데이터를 관리하거나 제어
    - URG 플래그: Urgent, 이 포인터가 가리키는 긴급한 데이터는 제일 먼저 처리
    - ACK 플래그: Acknowledgment number, 요청에 대한 응답 시 사용
    - PSH 플래그: TCP 버퍼가 일정한 크기만큼 쌓여야 전송을 하는데 버퍼를 채우지 않고 바로 전송을 수행(push) 하는 플래그
    - RST 플래그: 이미 TCP 연결이 되어 있을 때 이 연결을 강제로 해제하기 위해 사용
    - SYN 플래그: 상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위하여 사용
    - FIN 플래그: 연결 종료(전송할 데이터가 없음)를 의미
- Window Size(16): 자신의 수신 버퍼 여유용량 크기를 통보해 얼만큼의 데이터를 받을 수 있는지 상대방에게 알려주어 흐름제어
- Checksum: <b>데이터</b>를 송신하는 중에 발생할 수 있는 오류를 검출
- Urgent Pointer: 이 포인터가 가리키는 데이터는 긴급한 데이터로 처리되어 제일 먼저 처리

## TCP-흐름제어
: 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- Sliding Window: 수신 측에서 설정한 윈도우 크기만큼은 송신 측에서 확인 응답ACK를 받기 전에 전송 가능

## TCP-오류제어
: 훼손된 패킷을 감지 하고 중복 수신된 확인 후 폐기하며, 손실된 패킷은 재전송하고 순서에 맞지 않는 세그먼트를 버퍼에 저장하는 기법
- ARQ(자동반복 요청방식)
    - Stop-and-Wait ARQ
    : 수신측으로부터 ACK을 받을 때까지 대기하다가 전송하는 방법
    - Go-back-N ARQ
    : 오류가 난 지점부터 전송한 지점까지 모두 재전송 하는 기법
    - Selective Repeat ARQ
    : 오류가 난 부분만 재 전송하는 기법
    - Adaptive ARQ
    : 전송 효율을 최대한 높이기 위해 데이터 프레임의 길이를 동적으로 변경하여 전송

<br/>

## 응집도
: 모듈 내부의 기능적인 집중 정도

1. 우연적(Coincidental): 모듈 내부의 각 구성요소들이 연관이 없을 경우
2. 논리적(Logical): 유사한 성격을 갖는 요소들이 한 모듈에서 처리
3. 시간적(Temporal): 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
4. 절차적(Procedural): 모듈 안의 구성요소들이 그 기능을 순차적으로 수행
5. 통신적(Communicational): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
6. 순차적(Sequential): 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
7. 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

## 결합도
: 모듈과 모듈간의 상호 의존 정도

1. 자료(Data): 파라미터로 값만을 전달하는 경우
2. 스탬프(Stamp): 파라미터로 배열이나 오브젝트, 스트럭쳐 등의 객체가 전달되는 경우
3. 제어: 파라미터로 값뿐만 아니라 제어 요소도 전달되는 경우
4. 외부(External): 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우
5. 공통(Common): 공유되는 공통 데이터 영역(<b>전역변수</b>)을 여러 모듈이 사용하는 경우
6. 내용(Content): 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정하는 경우

<br/>

## OSI 7 Layer Model
1. 물리 계층(Physical Layer)
    - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
    - 단위: 비트
    - 주요 장비: 허브, 리피터 등
2. 데이터 링크 계층(Data Link Layer)
    - <b>인접</b> 노드 간 프레임 전송, 신뢰성 있는 정보 전달
    - 단위: 프레임
    - 주요 장비: 스위치, 브릿지 등
3. 네트워크 계층(Network Layer)
    - 단말기 간 데이터 전송을 위한 최적화된 경로 제공
    - 단위: 패킷
    - 주요 장비: 라우터 등
    - 프로토콜
        - IP: 데이터 전달
        - ICMP: IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜
        - ARP: 논리 주소인 IP 주소 ▶ 실제적인 물리 주소인 MAC 주소로 변환
        - RARP: 실제적인 물리 주소인 MAC 주소 ▶ 논리 주소인 IP 주소로 변환
4. 전송 계층(Transport Layer)
    - <b>단말기(종단)</b> 간의 연결. 신뢰성 있는 정보 전달
    - 단위: 세그먼트(TCP)/데이터그램(UDP)
    - 프로토콜
        - TCP
            - FTP(20-데이터, 21-제어): 파일 전송
            - telnet(23): 원격지의 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜
            - HTTP(80): 웹 서비스
            - SMTP(25): 메일 송신
            - POP3(110): 메일 수신
        - UDP
            - DHCP: IP 자동 할당
            - SNMP: 네트워크 관리
            - DNS(53): 도메인 ▶ IP 주소로 변환
5. 세션 계층(Session Layer)
    - 송수신 간의 논리적 연결
    - 단위: 데이터
6. 표현 계층(Presentation Layer)
    - 데이터 형식 설정, 암/복호화
    - 단위: 데이터
7. 응용 계층(Application Layer)
    - 일반적인 응용 서비스를 수행
    - 단위: 데이터

<br/>

## 기억 장치 배치 전략
1. 최초 적합 기법(first-fit strategy)
: 주기억장치의 첫 번째 유용한 공백을 우선적으로 선택하는 방법
2. 최적 적합 기법(best-fit strategy)
: 가장 적합한 공간을 선택함으로써 기억장치의 단편화를 최소로 하는 방법
3. 최악 적합 기법(worst-fit strategy)
: 프로그램을 주기억장치 내에서 가장 알맞지 않은 공백, 즉 가장 큰 공백에 배치하는 방법
- 예시
    - 20 ◀ 21: 외부단편화(20)
    - 50 ◀ 21: 내부단편화(29)

## Python Slice
```
str="Py thon."

len(str) = 8;
print str[5] = o;
print str[2:4] =  t;
print str[:3] = Py ;
print str[-2:] = n.;

```

<br/>

###### fork: UNIX에서 새로운 프로세스를 생성하는 명령어
