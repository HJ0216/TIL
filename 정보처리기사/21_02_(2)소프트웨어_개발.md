# 정보처리기사

## 시간복잡도에 따른 정렬 분류
- 선택(n^2)
    - 가장 적은 값을 맨 앞으로 이동 후, 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체
- 삽입(n^2)
    - 자료 배열의 모든 요소를 앞에서부터 차례대로 비교하면서 자리를 교환
- 버블(n^2)
    - 서로 인접한 두 원소의 크기를 비교하여 정렬
- 셸(n^2)
- Quick(nlog2n ~ n^2)
    - 분할정복(Divide & Conquer) 알고리즘, 피벗 사용
    - pivot 의 좌측에는 pivot 보다 작은값을 두고 우측에는 pivot 보다 큰 값을 두는 방식
- Heap(nlog2n)
- 병합(nlog2n)
    - 분할 정복 알고리즘

<br/>

## V모델
1. 단위(Unit) 테스트
: 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트
    - 정적: 소스코드의 실행없이 내부 확인
    - 동적: 입력값에 대한 출력값 확인
2. 통합(Integration) 테스트
: 단위 테스트를 통과한 컴포넌트 간의 인터페이스를 테스트
    - 빅뱅 테스트: 프로그램 전체를 대상으로 테스트
    - 상향식 테스트: 테스트 드라이버 사용
    - 하향식 테스트: 테스트 스텁 사용, 깊이 우선 통합법, 넓이 우선 통합법 사용
    - 백본(BackBone) 테스트: : 하위 수준에서는 상향식 통합, 상위수준에서는 하향식 통합 사용하여 최적의 테스트를 지원, 샌드위치(Sandwich)식 통합 테스트 방법
    - 회귀(Regression) 테스트: 통합 테스트가 완료된 후 변경된 모듈이나 컴포넌트가 있을 경우, 다른 부분에 영향을 미치는지 테스트하여 새로운 오류 여부를 확인
3. 시스템(System) 테스트
: 전체 시스템 또는 제품의 동작에 대해 테스트
    - 기능 요구사항 테스트
    - 비기능 요구사항 테스트: 기능 외 성능, 보안, 품질 등
4. 인수(Acceptance) 테스트
: 계약상의 요구사항이 만족되었는지 확인
    - 알파 테스트: 개발자 + 사용자
    - 베타 테스트: 사용자
    - 형상 테스트: 구조 확인

<br/>

## 소프트웨어 테스팅 7가지 기본 원칙
1. 테스트는 결함이 존재함을 밝히는 활동이다.
2. 완벽한 테스팅은 불가능하다
3. 테스팅은 개발 초기 단계에서부터 시작해야 한다
4. 결함 집중
    - 대다수의 결함은 소수의 특정 모듈에 집중되는 경향이 있다.
5. 살충제 패러독스
    - 동일한 테스트 케이스를 반복적으로 수행하는 경우 더 이상 새로운 결함을 찾아낼 수 없다.
6. 테스팅은 상황에 따라 이루어져야 한다.
7. 오류 부재의 귀변
    - 거의 모든 결함을 확인 후 제거하였다고 해도 사용자의 요구 또는 비즈니스 목적을 충족시키지 못하는 경우 품질이 높다고 할 수 없다.

<br/>

## 형상관리
: 비용을 제외하고 SW 개발 과정에서 발생하는 모든 변경사항을 관리

### 형상관리 절차
식별 → 통제(BaseLine 설정) → 감사 → 기록(형상 관리 위원회: Configuration Control Board)

### 형상관리 용어
|용어|설명|
|---|---|
|import|맨 처음 프로제트 시작 시 저장소에 등록|
|checkout|저장소에서 소스파일 받아오기|
|add|새 파일을 관리 파일로 추가|
|commit|수정한 파일을 저장소에 저장하여 갱신(=check-in)|
|update|저장소에 있는 최신 버전으로 자신의 작업공간을 동기화|
|diff|이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이 확인|
|merge|충돌난 파일에 대해 합치는 작업|
|trunk|개발 메인 디렉토리|
|branch|메인 개발 과정과 별도로 새로운 기능의 테스트와 같이 추가적인 작업을 수행하기 위한 서브 디렉토리|

### 형상관리 도구
- 중앙집중방식: CVS, SVN
- 분산방식: GIT

### 버전관리 도구
- 공유 폴더 방식: 인간 Merge
- 분산 저장소 방식
- 클라이언트-서버 방식: 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리
- Subversion (서브 버전, SVN): 클라이언트-서버 구조, 서버에는 최신 버전의 파일들과 변경 내역이 관리

<br/>

## 테스트
### 테스트 기법
- 화이트 박스 테스트: 모듈 내부 소스 코드를 보면서 수행하는 테스트, 개발자 수행
    - 종류
        - 기본 경로 커버리지(Base Path Coverage): 수행 가능한 모든 경로 테스트
        - 데이터 흐름 테스트(Data Flow Testing): 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞추어 검사
        - 조건 커버리지(Condition Coverage): 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행
        - 루프 테스트

- 블랙 박스 테스트: 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트, 사용자 수행
    - 동등(동치, 균등) 분할 테스트(Equivalence Partitioning Testing): 입력값의 범위를 유사한 특징을 갖는 동등그룹으로 나누고 각 그룹마다 대표값을 선정하는 테스트 기법
    - 경계값 분석 테스트(Boundary Value Analysis Testing): 경계값을 테스트 케이스로 선정하여 검사
    - 오류 예측 테스트
    - 원인-결과 그래프 테스트(Cause-Effect Graphing Testing)
    - 의사 결정 테이블 테스트
    - 상태 전이 테스트

### 테스트 목적
1. 회복: 시스템에 여러 가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인
2. 안전: 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인
3. 강도: 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인
4. 성능
5. 구조
6. 회귀: 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
7. 병행: 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력해 결과를 비교

### 테스트 기반
1. 명세 기반 테스트: 사용자의 요구사항 명세를 빠짐없이 구현하고 있는지 확인
2. 구조 기반 테스트: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인
3. 경험 기반 테스트: 테스터의 경험을 기반으로 수행

### 테스트 하네스(Test Harness)의 구성 요소
1. 테스트 드라이버: 상향식 테스트에서 사용하는 임시 모듈, 가상의 서버 역할
2. 테스트 스텁: 하향식 테스트에서 사용하는 임시 모듈, 가상의 클라이언트 역할
3. 테스트 케이스: <b>사용자의 요구사항을 정확하게 준수</b>했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서
4. 테스트 슈트: 테스트 케이스의 집합
5. 테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세서
6. 목 오브젝트: 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

<br/>

## Digital Rights Management
- 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 사용하는 접근 제어 기술
- 구성 요소
    - Clearing House: 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템
    - 콘텐츠 제공자(Contents Provider)
    - 패키저(Packager): 컨텐츠를 메타 데이터(컨텐츠를 설명하는 데이터)와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
    - 콘텐츠 분배자(Contents Distributor)
    - 콘텐츠 소비자(Customer)
    - DRM 컨트롤러(DRM Controller): 배포된 콘텐츠의 이용 권한을 통제하는 프로그램(멜론 등)
    - 보안 컨테이너(Security Container): 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- 기술 요소
    - 암호화(Encryption): 콘텐츠 및 라이선스를 암호화
    - 키 관리(key Management): 콘텐츠를 암호화한 키에 대한 저장 및 분배
    - 암호화 파일 생성(Packager): 콘텐츠를 암호화된 콘텐츠로 생성
    - 식별 기술(Identification)
    - 저작권 표현(Right Expression)
    - 정책 관리(Policy Management)
    - 크랙 방지(Tamper Resistance): 크랙(복제가 불가능 하도록 되어있는 파일)에 의한 콘텐츠 사용 방지 기술
    - 인증(Authentication): 라이선스 발급 및 사용의 기준이 되는 사용자 인증

<br>

## 연산 종류
- 전위 연산: +ab, 연산자-데이터-데이터 → 데이터-연산자-데이터
- 중위 연산: a+b, 데이터-연산자-데이터
- 후위 연산: ab+, 데이터-데이터-연산자 → 데이터-연산자-데이터

<br/>

## EAI ( Enterprise Application Integration )
: 기업에서 운영하는 서로 다른 플랫폼, App간의 정보 전달, 연계, 통합을 위한 솔루션
<img src="https://hyeonukdev.github.io/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0520_01.png" width="100%" alt="EAI_유형">

<br/>

## 인터페이스 구현 검증 도구
: 통합 테스트에서의 테스트 자동화 도구
- 종류
    - xUnit: 다양한 언어(x)를 지원하는 단위 테스트 프레임워크
    - STAF: 서비스 호출, 컴포넌트 재사용
    - FitNesse: 웹 기반 테스트케이스를 지원하는 테스트 프레임워크
    - NTAF: FitNesse의 장점인 협업과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
    - Selenium: 웹 어플리케이션 테스트 프레임워크
    - watir: Ruby(r)를 사용하는 애플리케이션 테스트 프레임워크

<br/>

## Clean Code 작성 원칙
: 가독성, 단순성(한 번에 한가지만 처리), 의존성, 중복성, 추상성
